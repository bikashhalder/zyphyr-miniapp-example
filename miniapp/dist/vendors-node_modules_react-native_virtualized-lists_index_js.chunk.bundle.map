{"version":3,"sources":["webpack://org-mini-app/node_modules/@react-native/virtualized-lists/Interaction/Batchinator.js","webpack://org-mini-app/node_modules/@react-native/virtualized-lists/Lists/CellRenderMask.js","webpack://org-mini-app/node_modules/@react-native/virtualized-lists/Lists/ChildListCollection.js","webpack://org-mini-app/node_modules/@react-native/virtualized-lists/Lists/FillRateHelper.js","webpack://org-mini-app/node_modules/@react-native/virtualized-lists/Lists/ListMetricsAggregator.js","webpack://org-mini-app/node_modules/@react-native/virtualized-lists/Lists/StateSafePureComponent.js","webpack://org-mini-app/node_modules/@react-native/virtualized-lists/Lists/ViewabilityHelper.js","webpack://org-mini-app/node_modules/@react-native/virtualized-lists/Lists/VirtualizeUtils.js","webpack://org-mini-app/node_modules/@react-native/virtualized-lists/Lists/VirtualizedList.js","webpack://org-mini-app/node_modules/@react-native/virtualized-lists/Lists/VirtualizedListCellRenderer.js","webpack://org-mini-app/node_modules/@react-native/virtualized-lists/Lists/VirtualizedListContext.js","webpack://org-mini-app/node_modules/@react-native/virtualized-lists/Lists/VirtualizedListProps.js","webpack://org-mini-app/node_modules/@react-native/virtualized-lists/Lists/VirtualizedSectionList.js","webpack://org-mini-app/node_modules/@react-native/virtualized-lists/Utilities/clamp.js","webpack://org-mini-app/node_modules/@react-native/virtualized-lists/Utilities/infoLog.js","webpack://org-mini-app/node_modules/@react-native/virtualized-lists/index.js"],"names":["dispose","Batchinator","schedule","invokeCallback","setTimeout","_ReactNativeFeatureFlags","timeoutHandle","_reactnative","clearTimeout","CellRenderMask","enumerateRegions","addCells","numCells","equals","_findRegion","_invariant","cells","_this__findRegion","_this__findRegion1","firstIntersect","newMainRegion","lastIntersect","newLeadRegion","lastIntersectIdx","_this__regions","other","region","Math","firstIdx","middleRegion","middleIdx","ChildListCollection","add","remove","forEach","forEachInCell","anyInCell","size","Map","Set","cellKey","cellLists","fn","Info","_listeners","_minSampleCount","_sampleRate","activate","FillRateHelper","deactivateAndFlush","computeBlankness","enabled","_resetData","global","info","listener","props","cellsAroundViewport","scrollMetrics","now","firstFrame","first","lastFrame","last","offset","blankTop","pixels_blank","console","callback","ListMetricsAggregator","notifyCellLayout","notifyCellUnmounted","notifyListContentLayout","getAverageCellLength","getHighestMeasuredCellIndex","getCellMetricsApprox","getCellMetrics","getCellOffsetApprox","getContentLength","hasContentLength","flowRelativeOffset","cartesianOffset","_invalidateIfOrientationChanged","_selectLength","_selectOffset","ref","next","curr","frame","highestMeasuredCellIndex","highestMeasuredCellFrame","index","getItemCount","_VirtualizeUtils","getItem","keyExtractor","_getItemLayout","Number","frameMetrics","remainder","_this__orientation","referenceContentLength","contentLength","orientation","_react","StateSafePureComponent","setState","_installSetStateHooks","partialState","that","_this","state","Object","require","invariant","_isEntirelyVisible","_getPixelsVisible","viewAreaMode","pixels","percent","top","bottom","ViewabilityHelper","computeViewableItems","onUpdate","resetViewableIndices","recordInteraction","_onUpdateSync","_this__config","viewAreaCoveragePercentThreshold","viewablePercentThreshold","itemVisiblePercentThreshold","_ref","itemCount","idx","metrics","_isViewable","JSON","viewableIndices","handle","v","onViewableItemsChanged","createViewToken","ii","key","viewable","key1","viewable1","changed","Array","offsets","offsetIndex","right","left","mid","prev","zoomScale","visibleBegin","windowSize","velocity","visibleEnd","listMetrics","_elementsThatOverlapOffsets","overscanFirst","overscanLast","newRangeCount","newCellCount","visible","Error","item","String","computeWindowedRenderLimits","elementsThatOverlapOffsets","_usedIndexForKey","_keylessItemComponentName","_StateSafePureComponent","_VirtualizedListContext","styles","threshold","scrollToEnd","VirtualizedList","scrollToIndex","scrollToItem","scrollToOffset","_scrollToParamsFromOffset","flashScrollIndicators","getScrollResponder","getScrollableNode","getScrollRef","setNativeProps","_getCellKey","hasMore","_checkProps","_adjustCellsAroundViewport","_findFirstChildWithMore","componentDidMount","componentWillUnmount","_pushCells","_isNestedWithSameOrientation","render","componentDidUpdate","_computeBlankness","_triggerRemeasureForChildListsInCell","measureLayoutRelativeToContainingList","_getFooterCellKey","_renderDebugOverlay","_orientation","_maybeCallOnEdgeReached","_maybeScrollToInitialScrollIndex","unstable_onScroll","_offsetFromScrollEvent","_scheduleCellsToRenderUpdate","_shouldRenderWithPriority","unstable_onScrollBeginDrag","unstable_onScrollEndDrag","unstable_onMomentumScrollBegin","unstable_onMomentumScrollEnd","__getListMetrics","_updateViewableItems","_ListMetricsAggregator","_ChildListCollection","_FillRateHelper","_Batchinator","_this_props","_ViewabilityHelper","pair","_this_props_maintainVisibleContentPosition","childList","newProps","isVertical","otherProps","e","visibleLength","dOffset","timestamp","_infoLog","tuple","lastFocusedCellRenderer","heightOfCellsBeforeFocused","i","heightOfCellsAfterFocused","i1","params","onScrollToIndexFailed","viewPosition","viewOffset","scrollRef","horizontal","t","_this_context","onScroll","_VirtualizedListProps","_this__scrollMetrics","newCellsAroundViewport","onEndReachedThreshold","distanceFromEnd","childIdx","CellRendererComponent","ItemSeparatorComponent","ListItemComponent","data","debug","getItemLayout","renderItem","ListHeaderComponent","stickyOffset","end","stickyIndicesFromProps","stickyHeaderIndices","_VirtualizedListCellRenderer","inversionStyle","prevCellKey","shouldListenForLayout","nestedContext","_this_props1","ListEmptyComponent","element1","renderRegions","lastRegion","section","isLastSpacer","constrainToMeasured","_clamp","lastMetrics","firstMetrics","ListFooterComponent","prevProps","error","normalize","frameLast","windowTop","windowLen","visTop","visLen","f","onStartReachedThreshold","distanceFromStart","onEndReached","onStartReached","_nullthrows","_e_nativeEvent","_this_state_cellsAroundViewport","distTop","getScrollingThreshold","distBottom","_CellRenderMask","additionalRegions","firstCellIndex","cellIdx","itemIdx","prevState","_newProps_maintainVisibleContentPosition","prevFirstVisibleItemKey","newFirstVisibleItemKey","firstVisibleItemIndex","maintainVisibleContentPositionAdjustment","lastPossibleCellIndex","CellRenderer","updateSeparatorProps","_renderElement","select","onCellLayout","VirtualizedListContext","value","currContext","VirtualizedListCellContextProvider","VirtualizedListContextProvider","VirtualizedListContextResetter","initialNumToRender","maxToRenderPerBatch","horizontalOrDefault","initialNumToRenderOrDefault","maxToRenderPerBatchOrDefault","onEndReachedThresholdOrDefault","onStartReachedThresholdOrDefault","windowSizeOrDefault","LeadingSeparatorComponent","SeparatorComponent","setSelfHighlightCallback","updateHighlightFor","setSelfUpdatePropsCallback","updatePropsFor","_React_useState","setLeadingSeparatorHighlighted","_React_useState1","setSeparatorHighlighted","_React_useState2","leadingSeparatorProps","setLeadingSeparatorProps","_React_useState3","separatorProps","setSeparatorProps","leadingSeparator","inverted","RenderSeparator","scrollToLocation","VirtualizedSectionList","getListRef","_getItem","_subExtractor","_getSeparatorComponent","keyExtractorWithNullableIndex","keyExtractorWithNonNullableIndex","viewableItems","Boolean","listItemCount","ItemWithSeparator","infoIndex","renderSectionFooter","renderSectionHeader","updateProps","updateHighlight","listRef","passThroughProps","_VirtualizedList","sections","itemIndex","extractor","_console"],"mappings":"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IAFJA,EACI,EAAa,QAAA,KAAD,IAAA,IAAZ,OAHyB,KAKT,EACR,QAAA,KAAD,IAAA,IADS,IALS,KAQxB,KAAA,KARwB,IAWb,UAXa,IAgBjB,UAhBiB,KAsBZ,UAtBY,KA0BR,UA1BQ,KA+BT,UA/BS,KAAD,KAA1B0K,OAsCQ,M,EAx5Dd,MACUC,OAAAA,IAAR,EAgCF,EAAA,KAAA,I,G,I,Q,M,I,K,M,IAIEC,K,IAJIC,IAAAA,I,M,IAwBJC,K,IAxBID,I,M,IAoFJE,K,IApFIF,I,M,IAgHJG,K,IAhHIH,I,M,IA+IJI,K,IA/IIJ,I,M,IA4JJtD,K,IA5JIsD,I,M,IAsKJK,K,IAtKIL,I,M,IAmLJM,K,IAnLIN,I,M,IAyLJO,K,IAzLIP,I,M,IAiMJQ,K,IAjMIR,I,M,IA2MJS,K,IA3MIT,I,M,IAiNJU,K,IAjNIV,I,M,IA0NJW,K,IA1NIX,I,M,IAySJY,K,IAzSIZ,I,M,IA2cJa,K,IA3cIb,I,M,IAuhBJc,K,IAvhBId,I,M,IAuiBJe,K,IAviBIf,I,M,IAgjBJgB,K,IAhjBIhB,I,M,IA2nBJiB,K,IA3nBIjB,I,M,IAytBJkB,K,IAztBIlB,I,M,IA0vBJmB,K,IA1vBInB,I,M,IA2gCJoB,K,IA3gCIpB,I,M,IA0lCJqB,K,IA1lCIrB,I,M,IA2qCJsB,K,IA3qCItB,I,M,IAirCJuB,K,IAjrCIvB,I,M,IAuvCJwB,K,IAvvCIxB,I,M,IAqwCJyB,K,IArwCIzB,I,M,IAo0CJjG,K,IAp0CIiG,I,M,IAg1CJhG,K,IAh1CIgG,I,M,IAo1CJ0B,K,IAp1CI1B,I,M,IA21CJ2B,K,IA31CI3B,I,M,IAw8CJ4B,K,IAx8CI5B,I,M,IA2/CJ6B,K,IA3/CI7B,I,M,IAykDJ8B,K,IAzkDI9B,I,M,IAulDJ+B,K,IAvlDI/B,I,M,IAgnDJgC,K,IAhnDIhC,I,M,IAupDJiC,K,IAvpDIjC,I,M,IAsqDJkC,K,IAtqDIlC,I,M,IAsrDJmC,K,IAtrDInC,I,M,IAisDJoC,K,IAjsDIpC,I,M,IAyvDJqC,K,IAzvDIrC,I,M,IA0zDJsC,K,IA1zDItC,I,M,IAyVJ,K,I,I,I,M,IAq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","sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *       strict-local\n * @format\n */\n\nimport {InteractionManager} from 'react-native';\nimport * as ReactNativeFeatureFlags from 'react-native/src/private/featureflags/ReactNativeFeatureFlags';\n\n/**\n * A simple class for batching up invocations of a low-pri callback. A timeout is set to run the\n * callback once after a delay, no matter how many times it's scheduled. Once the delay is reached,\n * InteractionManager.runAfterInteractions is used to invoke the callback after any hi-pri\n * interactions are done running.\n *\n * Make sure to cleanup with dispose().  Example:\n *\n *   class Widget extends React.Component {\n *     _batchedSave: new Batchinator(() => this._saveState, 1000);\n *     _saveSate() {\n *       // save this.state to disk\n *     }\n *     componentDidUpdate() {\n *       this._batchedSave.schedule();\n *     }\n *     componentWillUnmount() {\n *       this._batchedSave.dispose();\n *     }\n *     ...\n *   }\n */\nclass Batchinator {\n  _callback            ;\n  _delay        ;\n  _taskHandle                            ;\n\n  constructor(callback            , delay        ) {\n    this._delay = delay;\n    this._callback = callback;\n  }\n\n  /*\n   * Cleanup any pending tasks.\n   *\n   * By default, if there is a pending task the callback is run immediately. Set the option abort to\n   * true to not call the callback if it was pending.\n   */\n  dispose()       {\n    if (this._taskHandle) {\n      this._taskHandle.cancel();\n      this._taskHandle = null;\n    }\n  }\n\n  schedule()       {\n    if (this._taskHandle) {\n      return;\n    }\n    const invokeCallback = () => {\n      // Note that we clear the handle before invoking the callback so that if the callback calls\n      // schedule again, it will actually schedule another task.\n      this._taskHandle = null;\n      this._callback();\n    };\n\n    const timeoutHandle = setTimeout(\n      // NOTE: When shipping this, delete `Batchinator` instead of only these\n      // lines of code. Without `InteractionManager`, it's just a `setTimeout`.\n      ReactNativeFeatureFlags.disableInteractionManagerInBatchinator()\n        ? invokeCallback\n        : () => {\n            this._taskHandle =\n              InteractionManager.runAfterInteractions(invokeCallback);\n          },\n      this._delay,\n    );\n    this._taskHandle = {cancel: () => clearTimeout(timeoutHandle)};\n  }\n}\n\nmodule.exports = Batchinator;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *       strict\n * @format\n */\n\nimport invariant from 'invariant';\n\n                          \n                \n               \n                    \n  \n\nexport class CellRenderMask {\n  _numCells        ;\n  _regions                   ;\n\n  constructor(numCells        ) {\n    invariant(\n      numCells >= 0,\n      'CellRenderMask must contain a non-negative number os cells',\n    );\n\n    this._numCells = numCells;\n\n    if (numCells === 0) {\n      this._regions = [];\n    } else {\n      this._regions = [\n        {\n          first: 0,\n          last: numCells - 1,\n          isSpacer: true,\n        },\n      ];\n    }\n  }\n\n  enumerateRegions()                             {\n    return this._regions;\n  }\n\n  addCells(cells                               )       {\n    invariant(\n      cells.first >= 0 &&\n        cells.first < this._numCells &&\n        cells.last >= -1 &&\n        cells.last < this._numCells &&\n        cells.last >= cells.first - 1,\n      'CellRenderMask.addCells called with invalid cell range',\n    );\n\n    // VirtualizedList uses inclusive ranges, where zero-count states are\n    // possible. E.g. [0, -1] for no cells, starting at 0.\n    if (cells.last < cells.first) {\n      return;\n    }\n\n    const [firstIntersect, firstIntersectIdx] = this._findRegion(cells.first);\n    const [lastIntersect, lastIntersectIdx] = this._findRegion(cells.last);\n\n    // Fast-path if the cells to add are already all present in the mask. We\n    // will otherwise need to do some mutation.\n    if (firstIntersectIdx === lastIntersectIdx && !firstIntersect.isSpacer) {\n      return;\n    }\n\n    // We need to replace the existing covered regions with 1-3 new regions\n    // depending whether we need to split spacers out of overlapping regions.\n    const newLeadRegion                    = [];\n    const newTailRegion                    = [];\n    const newMainRegion             = {\n      ...cells,\n      isSpacer: false,\n    };\n\n    if (firstIntersect.first < newMainRegion.first) {\n      if (firstIntersect.isSpacer) {\n        newLeadRegion.push({\n          first: firstIntersect.first,\n          last: newMainRegion.first - 1,\n          isSpacer: true,\n        });\n      } else {\n        newMainRegion.first = firstIntersect.first;\n      }\n    }\n\n    if (lastIntersect.last > newMainRegion.last) {\n      if (lastIntersect.isSpacer) {\n        newTailRegion.push({\n          first: newMainRegion.last + 1,\n          last: lastIntersect.last,\n          isSpacer: true,\n        });\n      } else {\n        newMainRegion.last = lastIntersect.last;\n      }\n    }\n\n    const replacementRegions                    = [\n      ...newLeadRegion,\n      newMainRegion,\n      ...newTailRegion,\n    ];\n    const numRegionsToDelete = lastIntersectIdx - firstIntersectIdx + 1;\n    this._regions.splice(\n      firstIntersectIdx,\n      numRegionsToDelete,\n      ...replacementRegions,\n    );\n  }\n\n  numCells()         {\n    return this._numCells;\n  }\n\n  equals(other                )          {\n    return (\n      this._numCells === other._numCells &&\n      this._regions.length === other._regions.length &&\n      this._regions.every(\n        (region, i) =>\n          region.first === other._regions[i].first &&\n          region.last === other._regions[i].last &&\n          region.isSpacer === other._regions[i].isSpacer,\n      )\n    );\n  }\n\n  _findRegion(cellIdx        )                       {\n    let firstIdx = 0;\n    let lastIdx = this._regions.length - 1;\n\n    while (firstIdx <= lastIdx) {\n      const middleIdx = Math.floor((firstIdx + lastIdx) / 2);\n      const middleRegion = this._regions[middleIdx];\n\n      if (cellIdx >= middleRegion.first && cellIdx <= middleRegion.last) {\n        return [middleRegion, middleIdx];\n      } else if (cellIdx < middleRegion.first) {\n        lastIdx = middleIdx - 1;\n      } else if (cellIdx > middleRegion.last) {\n        firstIdx = middleIdx + 1;\n      }\n    }\n\n    invariant(false, `A region was not found containing cellIdx ${cellIdx}`);\n  }\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *       strict\n * @format\n */\n\nimport invariant from 'invariant';\n\nexport default class ChildListCollection        {\n  _cellKeyToChildren                          = new Map();\n  _childrenToCellKey                     = new Map();\n\n  add(list       , cellKey        )       {\n    invariant(\n      !this._childrenToCellKey.has(list),\n      'Trying to add already present child list',\n    );\n\n    const cellLists = this._cellKeyToChildren.get(cellKey) ?? new Set();\n    cellLists.add(list);\n    this._cellKeyToChildren.set(cellKey, cellLists);\n\n    this._childrenToCellKey.set(list, cellKey);\n  }\n\n  remove(list       )       {\n    const cellKey = this._childrenToCellKey.get(list);\n    invariant(cellKey != null, 'Trying to remove non-present child list');\n    this._childrenToCellKey.delete(list);\n\n    const cellLists = this._cellKeyToChildren.get(cellKey);\n    invariant(cellLists, '_cellKeyToChildren should contain cellKey');\n    cellLists.delete(list);\n\n    if (cellLists.size === 0) {\n      this._cellKeyToChildren.delete(cellKey);\n    }\n  }\n\n  forEach(fn               )       {\n    for (const listSet of this._cellKeyToChildren.values()) {\n      for (const list of listSet) {\n        fn(list);\n      }\n    }\n  }\n\n  forEachInCell(cellKey        , fn               )       {\n    const listSet = this._cellKeyToChildren.get(cellKey) ?? [];\n    for (const list of listSet) {\n      fn(list);\n    }\n  }\n\n  anyInCell(cellKey        , fn                  )          {\n    const listSet = this._cellKeyToChildren.get(cellKey) ?? [];\n    for (const list of listSet) {\n      if (fn(list)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  size()         {\n    return this._childrenToCellKey.size;\n  }\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *      \n * @format\n */\n\n'use strict';\n\n                                                             \n\nimport ListMetricsAggregator from './ListMetricsAggregator';\n\n                                \n\nclass Info {\n  any_blank_count         = 0;\n  any_blank_ms         = 0;\n  any_blank_speed_sum         = 0;\n  mostly_blank_count         = 0;\n  mostly_blank_ms         = 0;\n  pixels_blank         = 0;\n  pixels_sampled         = 0;\n  pixels_scrolled         = 0;\n  total_time_spent         = 0;\n  sample_count         = 0;\n}\n\nconst DEBUG = false;\n\nlet _listeners                        = [];\nlet _minSampleCount = 10;\nlet _sampleRate = DEBUG ? 1 : null;\n\n/**\n * A helper class for detecting when the maximem fill rate of `VirtualizedList` is exceeded.\n * By default the sampling rate is set to zero and this will do nothing. If you want to collect\n * samples (e.g. to log them), make sure to call `FillRateHelper.setSampleRate(0.0-1.0)`.\n *\n * Listeners and sample rate are global for all `VirtualizedList`s - typical usage will combine with\n * `SceneTracker.getActiveScene` to determine the context of the events.\n */\nclass FillRateHelper {\n  _anyBlankStartTime          = null;\n  _enabled = false;\n  _listMetrics                       ;\n  _info       = new Info();\n  _mostlyBlankStartTime          = null;\n  _samplesStartTime          = null;\n\n  static addListener(callback                      )   \n                       \n       \n    {\n    if (_sampleRate === null) {\n      console.warn('Call `FillRateHelper.setSampleRate` before `addListener`.');\n    }\n    _listeners.push(callback);\n    return {\n      remove: () => {\n        _listeners = _listeners.filter(listener => callback !== listener);\n      },\n    };\n  }\n\n  static setSampleRate(sampleRate        ) {\n    _sampleRate = sampleRate;\n  }\n\n  static setMinSampleCount(minSampleCount        ) {\n    _minSampleCount = minSampleCount;\n  }\n\n  constructor(listMetrics                       ) {\n    this._listMetrics = listMetrics;\n    this._enabled = (_sampleRate || 0) > Math.random();\n    this._resetData();\n  }\n\n  activate() {\n    if (this._enabled && this._samplesStartTime == null) {\n      DEBUG && console.debug('FillRateHelper: activate');\n      this._samplesStartTime = global.performance.now();\n    }\n  }\n\n  deactivateAndFlush() {\n    if (!this._enabled) {\n      return;\n    }\n    const start = this._samplesStartTime; // const for flow\n    if (start == null) {\n      DEBUG &&\n        console.debug('FillRateHelper: bail on deactivate with no start time');\n      return;\n    }\n    if (this._info.sample_count < _minSampleCount) {\n      // Don't bother with under-sampled events.\n      this._resetData();\n      return;\n    }\n    const total_time_spent = global.performance.now() - start;\n    const info      = {\n      ...this._info,\n      total_time_spent,\n    };\n    if (DEBUG) {\n      const derived = {\n        avg_blankness: this._info.pixels_blank / this._info.pixels_sampled,\n        avg_speed: this._info.pixels_scrolled / (total_time_spent / 1000),\n        avg_speed_when_any_blank:\n          this._info.any_blank_speed_sum / this._info.any_blank_count,\n        any_blank_per_min:\n          this._info.any_blank_count / (total_time_spent / 1000 / 60),\n        any_blank_time_frac: this._info.any_blank_ms / total_time_spent,\n        mostly_blank_per_min:\n          this._info.mostly_blank_count / (total_time_spent / 1000 / 60),\n        mostly_blank_time_frac: this._info.mostly_blank_ms / total_time_spent,\n      };\n      for (const key in derived) {\n        // $FlowFixMe[prop-missing]\n        // $FlowFixMe[invalid-computed-prop]\n        derived[key] = Math.round(1000 * derived[key]) / 1000;\n      }\n      console.debug('FillRateHelper deactivateAndFlush: ', {derived, info});\n    }\n    _listeners.forEach(listener => listener(info));\n    this._resetData();\n  }\n\n  computeBlankness(\n    props   \n                         \n                                   \n         \n     ,\n    cellsAroundViewport   \n                    \n                   \n         \n     ,\n    scrollMetrics   \n                      \n                     \n                       \n                            \n         \n     ,\n  )         {\n    if (\n      !this._enabled ||\n      props.getItemCount(props.data) === 0 ||\n      cellsAroundViewport.last < cellsAroundViewport.first ||\n      this._samplesStartTime == null\n    ) {\n      return 0;\n    }\n    const {dOffset, offset, velocity, visibleLength} = scrollMetrics;\n\n    // Denominator metrics that we track for all events - most of the time there is no blankness and\n    // we want to capture that.\n    this._info.sample_count++;\n    this._info.pixels_sampled += Math.round(visibleLength);\n    this._info.pixels_scrolled += Math.round(Math.abs(dOffset));\n    const scrollSpeed = Math.round(Math.abs(velocity) * 1000); // px / sec\n\n    // Whether blank now or not, record the elapsed time blank if we were blank last time.\n    const now = global.performance.now();\n    if (this._anyBlankStartTime != null) {\n      this._info.any_blank_ms += now - this._anyBlankStartTime;\n    }\n    this._anyBlankStartTime = null;\n    if (this._mostlyBlankStartTime != null) {\n      this._info.mostly_blank_ms += now - this._mostlyBlankStartTime;\n    }\n    this._mostlyBlankStartTime = null;\n\n    let blankTop = 0;\n    let first = cellsAroundViewport.first;\n    let firstFrame = this._listMetrics.getCellMetrics(first, props);\n    while (\n      first <= cellsAroundViewport.last &&\n      (!firstFrame || !firstFrame.isMounted)\n    ) {\n      firstFrame = this._listMetrics.getCellMetrics(first, props);\n      first++;\n    }\n    // Only count blankTop if we aren't rendering the first item, otherwise we will count the header\n    // as blank.\n    if (firstFrame && first > 0) {\n      blankTop = Math.min(\n        visibleLength,\n        Math.max(0, firstFrame.offset - offset),\n      );\n    }\n    let blankBottom = 0;\n    let last = cellsAroundViewport.last;\n    let lastFrame = this._listMetrics.getCellMetrics(last, props);\n    while (\n      last >= cellsAroundViewport.first &&\n      (!lastFrame || !lastFrame.isMounted)\n    ) {\n      lastFrame = this._listMetrics.getCellMetrics(last, props);\n      last--;\n    }\n    // Only count blankBottom if we aren't rendering the last item, otherwise we will count the\n    // footer as blank.\n    if (lastFrame && last < props.getItemCount(props.data) - 1) {\n      const bottomEdge = lastFrame.offset + lastFrame.length;\n      blankBottom = Math.min(\n        visibleLength,\n        Math.max(0, offset + visibleLength - bottomEdge),\n      );\n    }\n    const pixels_blank = Math.round(blankTop + blankBottom);\n    const blankness = pixels_blank / visibleLength;\n    if (blankness > 0) {\n      this._anyBlankStartTime = now;\n      this._info.any_blank_speed_sum += scrollSpeed;\n      this._info.any_blank_count++;\n      this._info.pixels_blank += pixels_blank;\n      if (blankness > 0.5) {\n        this._mostlyBlankStartTime = now;\n        this._info.mostly_blank_count++;\n      }\n    } else if (scrollSpeed < 0.01 || Math.abs(dOffset) < 1) {\n      this.deactivateAndFlush();\n    }\n    return blankness;\n  }\n\n  enabled()          {\n    return this._enabled;\n  }\n\n  _resetData() {\n    this._anyBlankStartTime = null;\n    this._info = new Info();\n    this._mostlyBlankStartTime = null;\n    this._samplesStartTime = null;\n  }\n}\n\nmodule.exports = FillRateHelper;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *       strict-local\n * @format\n */\n\n                                                                          \n                                                                        \n\nimport {keyExtractor as defaultKeyExtractor} from './VirtualizeUtils';\nimport invariant from 'invariant';\n\n                           \n     \n                                  \n     \n                \n     \n                                                \n     \n                 \n     \n                                                                             \n         \n     \n                 \n     \n                                                 \n     \n                     \n  \n\n// TODO: `inverted` can be incorporated here if it is moved to an order\n// based implementation instead of transform.\n                               \n                      \n               \n  \n\n/**\n * Subset of VirtualizedList props needed to calculate cell metrics\n */\n                               \n                                     \n                                                     \n                                           \n                                                        \n                                                      \n     \n  \n\n/**\n * Provides an interface to query information about the metrics of a list and its cells.\n */\nexport default class ListMetricsAggregator {\n  _averageCellLength = 0;\n  _cellMetrics                           = new Map();\n  _contentLength         ;\n  _highestMeasuredCellIndex = 0;\n  _measuredCellsLength = 0;\n  _measuredCellsCount = 0;\n  _orientation                  = {\n    horizontal: false,\n    rtl: false,\n  };\n\n  /**\n   * Notify the ListMetricsAggregator that a cell has been laid out.\n   *\n   * @returns whether the cell layout has changed since last notification\n   */\n  notifyCellLayout({\n    cellIndex,\n    cellKey,\n    orientation,\n    layout,\n  }   \n                      \n                    \n                                 \n                   \n   )          {\n    this._invalidateIfOrientationChanged(orientation);\n\n    const next              = {\n      index: cellIndex,\n      length: this._selectLength(layout),\n      isMounted: true,\n      offset: this.flowRelativeOffset(layout),\n    };\n    const curr = this._cellMetrics.get(cellKey);\n\n    if (!curr || next.offset !== curr.offset || next.length !== curr.length) {\n      if (curr) {\n        const dLength = next.length - curr.length;\n        this._measuredCellsLength += dLength;\n      } else {\n        this._measuredCellsLength += next.length;\n        this._measuredCellsCount += 1;\n      }\n\n      this._averageCellLength =\n        this._measuredCellsLength / this._measuredCellsCount;\n      this._cellMetrics.set(cellKey, next);\n      this._highestMeasuredCellIndex = Math.max(\n        this._highestMeasuredCellIndex,\n        cellIndex,\n      );\n      return true;\n    } else {\n      curr.isMounted = true;\n      return false;\n    }\n  }\n\n  /**\n   * Notify ListMetricsAggregator that a cell has been unmounted.\n   */\n  notifyCellUnmounted(cellKey        )       {\n    const curr = this._cellMetrics.get(cellKey);\n    if (curr) {\n      curr.isMounted = false;\n    }\n  }\n\n  /**\n   * Notify ListMetricsAggregator that the lists content container has been laid out.\n   */\n  notifyListContentLayout({\n    orientation,\n    layout,\n  }   \n                                 \n                                                       \n   )       {\n    this._invalidateIfOrientationChanged(orientation);\n    this._contentLength = this._selectLength(layout);\n  }\n\n  /**\n   * Return the average length of the cells which have been measured\n   */\n  getAverageCellLength()         {\n    return this._averageCellLength;\n  }\n\n  /**\n   * Return the highest measured cell index (or 0 if nothing has been measured\n   * yet)\n   */\n  getHighestMeasuredCellIndex()         {\n    return this._highestMeasuredCellIndex;\n  }\n\n  /**\n   * Returns the exact metrics of a cell if it has already been laid out,\n   * otherwise an estimate based on the average length of previously measured\n   * cells\n   */\n  getCellMetricsApprox(index        , props                 )              {\n    const frame = this.getCellMetrics(index, props);\n    if (frame && frame.index === index) {\n      // check for invalid frames due to row re-ordering\n      return frame;\n    } else {\n      let offset;\n\n      const highestMeasuredCellIndex = this.getHighestMeasuredCellIndex();\n      if (highestMeasuredCellIndex < index) {\n        // If any of the cells before this one have been laid out already, we\n        // should use that information in the estimations.\n        // This is important because if the list has a header, the initial cell\n        // will have a larger offset that we should take into account here.\n        const highestMeasuredCellFrame = this.getCellMetrics(\n          highestMeasuredCellIndex,\n          props,\n        );\n        if (highestMeasuredCellFrame) {\n          offset =\n            highestMeasuredCellFrame.offset +\n            highestMeasuredCellFrame.length +\n            this._averageCellLength * (index - highestMeasuredCellIndex - 1);\n        }\n      }\n\n      if (offset == null) {\n        offset = this._averageCellLength * index;\n      }\n\n      const {data, getItemCount} = props;\n      invariant(\n        index >= 0 && index < getItemCount(data),\n        'Tried to get frame for out of range index ' + index,\n      );\n      return {\n        length: this._averageCellLength,\n        offset,\n        index,\n        isMounted: false,\n      };\n    }\n  }\n\n  /**\n   * Returns the exact metrics of a cell if it has already been laid out\n   */\n  getCellMetrics(index        , props                 )               {\n    const {data, getItem, getItemCount, getItemLayout} = props;\n    invariant(\n      index >= 0 && index < getItemCount(data),\n      'Tried to get metrics for out of range cell index ' + index,\n    );\n    const keyExtractor = props.keyExtractor ?? defaultKeyExtractor;\n    const frame = this._cellMetrics.get(\n      keyExtractor(getItem(data, index), index),\n    );\n    if (frame && frame.index === index) {\n      return frame;\n    }\n\n    if (getItemLayout) {\n      const {length, offset} = getItemLayout(data, index);\n      // TODO: `isMounted` is used for both \"is exact layout\" and \"has been\n      // unmounted\". Should be refactored.\n      return {index, length, offset, isMounted: true};\n    }\n\n    return null;\n  }\n\n  /**\n   * Gets an approximate offset to an item at a given index. Supports\n   * fractional indices.\n   */\n  getCellOffsetApprox(index        , props                 )         {\n    if (Number.isInteger(index)) {\n      return this.getCellMetricsApprox(index, props).offset;\n    } else {\n      const frameMetrics = this.getCellMetricsApprox(Math.floor(index), props);\n      const remainder = index - Math.floor(index);\n      return frameMetrics.offset + remainder * frameMetrics.length;\n    }\n  }\n\n  /**\n   * Returns the length of all ScrollView content along the scrolling axis.\n   */\n  getContentLength()         {\n    return this._contentLength ?? 0;\n  }\n\n  /**\n   * Whether a content length has been observed\n   */\n  hasContentLength()          {\n    return this._contentLength != null;\n  }\n\n  /**\n   * Finds the flow-relative offset (e.g. starting from the left in LTR, but\n   * right in RTL) from a layout box.\n   */\n  flowRelativeOffset(layout        , referenceContentLength          )         {\n    const {horizontal, rtl} = this._orientation;\n\n    if (horizontal && rtl) {\n      const contentLength = referenceContentLength ?? this._contentLength;\n      invariant(\n        contentLength != null,\n        'ListMetricsAggregator must be notified of list content layout before resolving offsets',\n      );\n      return (\n        contentLength -\n        (this._selectOffset(layout) + this._selectLength(layout))\n      );\n    } else {\n      return this._selectOffset(layout);\n    }\n  }\n\n  /**\n   * Converts a flow-relative offset to a cartesian offset\n   */\n  cartesianOffset(flowRelativeOffset        )         {\n    const {horizontal, rtl} = this._orientation;\n\n    if (horizontal && rtl) {\n      invariant(\n        this._contentLength != null,\n        'ListMetricsAggregator must be notified of list content layout before resolving offsets',\n      );\n      return this._contentLength - flowRelativeOffset;\n    } else {\n      return flowRelativeOffset;\n    }\n  }\n\n  _invalidateIfOrientationChanged(orientation                 )       {\n    if (orientation.rtl !== this._orientation.rtl) {\n      this._cellMetrics.clear();\n    }\n\n    if (orientation.horizontal !== this._orientation.horizontal) {\n      this._averageCellLength = 0;\n      this._highestMeasuredCellIndex = 0;\n      this._measuredCellsLength = 0;\n      this._measuredCellsCount = 0;\n    }\n\n    this._orientation = orientation;\n  }\n\n  _selectLength({\n    width,\n    height,\n  }                                                 )         {\n    return this._orientation.horizontal ? width : height;\n  }\n\n  _selectOffset({x, y}                                        )         {\n    return this._orientation.horizontal ? x : y;\n  }\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *       strict\n * @format\n */\n\nimport invariant from 'invariant';\nimport * as React from 'react';\n\n/**\n * `setState` is called asynchronously, and should not rely on the value of\n * `this.props` or `this.state`:\n * https://react.dev/docs/state-and-lifecycle.html#state-updates-may-be-asynchronous\n *\n * SafePureComponent adds runtime enforcement, to catch cases where these\n * variables are read in a state updater function, instead of the ones passed\n * in.\n */\nexport default class StateSafePureComponent \n        \n                      \n  extends React.PureComponent               {\n  _inAsyncStateUpdate = false;\n\n  constructor(props       ) {\n    super(props);\n    this._installSetStateHooks();\n  }\n\n  setState(\n    partialState                                                         ,\n    callback              ,\n  )       {\n    if (typeof partialState === 'function') {\n      super.setState((state, props) => {\n        this._inAsyncStateUpdate = true;\n        let ret;\n        try {\n          ret = partialState(state, props);\n        } catch (err) {\n          throw err;\n        } finally {\n          this._inAsyncStateUpdate = false;\n        }\n        return ret;\n      }, callback);\n    } else {\n      super.setState(partialState, callback);\n    }\n  }\n\n  _installSetStateHooks() {\n    const that = this;\n    let {props, state} = this;\n\n    Object.defineProperty(this, 'props', {\n      get() {\n        invariant(\n          !that._inAsyncStateUpdate,\n          '\"this.props\" should not be accessed during state updates',\n        );\n        return props;\n      },\n      set(newProps       ) {\n        props = newProps;\n      },\n    });\n    Object.defineProperty(this, 'state', {\n      get() {\n        invariant(\n          !that._inAsyncStateUpdate,\n          '\"this.state\" should not be acceessed during state updates',\n        );\n        return state;\n      },\n      set(newState       ) {\n        state = newState;\n      },\n    });\n  }\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *      \n * @format\n */\n\n'use strict';\n\n                                                             \n\nimport ListMetricsAggregator from './ListMetricsAggregator';\n\nconst invariant = require('invariant');\n\n                         \n            \n              \n                 \n                      \n                \n     \n  \n\n                                             \n                                       \n                                  \n                                    \n                              \n       \n             \n     \n  \n\n                                            \n     \n                                                                                                 \n                                                                                                   \n                                                    \n     \n                           \n\n     \n                                                                                       \n                                                                                              \n                                                                                               \n                                                                                               \n     \n                                            \n\n     \n                                                                                                  \n                                                             \n     \n                                       \n\n     \n                                                                                                 \n            \n     \n                               \n    \n\n/**\n * A Utility class for calculating viewable items based on current metrics like scroll position and\n * layout.\n *\n * An item is said to be in a \"viewable\" state when any of the following\n * is true for longer than `minimumViewTime` milliseconds (after an interaction if `waitForInteraction`\n * is true):\n *\n * - Occupying >= `viewAreaCoveragePercentThreshold` of the view area XOR fraction of the item\n *   visible in the view area >= `itemVisiblePercentThreshold`.\n * - Entirely visible on screen\n */\nclass ViewabilityHelper {\n  _config                   ;\n  _hasInteracted          = false;\n  _timers              = new Set();\n  _viewableIndices                = [];\n  _viewableItems                         = new Map();\n\n  constructor(\n    config                    = {viewAreaCoveragePercentThreshold: 0},\n  ) {\n    this._config = config;\n  }\n\n  /**\n   * Cleanup, e.g. on unmount. Clears any pending timers.\n   */\n  dispose() {\n    /* $FlowFixMe[incompatible-call] (>=0.63.0 site=react_native_fb) This\n     * comment suppresses an error found when Flow v0.63 was deployed. To see\n     * the error delete this comment and run Flow. */\n    this._timers.forEach(clearTimeout);\n  }\n\n  /**\n   * Determines which items are viewable based on the current metrics and config.\n   */\n  computeViewableItems(\n    props                 ,\n    scrollOffset        ,\n    viewportHeight        ,\n    listMetrics                       ,\n    // Optional optimization to reduce the scan size\n    renderRange    \n                    \n                   \n         \n     ,\n  )                {\n    const itemCount = props.getItemCount(props.data);\n    const {itemVisiblePercentThreshold, viewAreaCoveragePercentThreshold} =\n      this._config;\n    const viewAreaMode = viewAreaCoveragePercentThreshold != null;\n    const viewablePercentThreshold = viewAreaMode\n      ? viewAreaCoveragePercentThreshold\n      : itemVisiblePercentThreshold;\n    invariant(\n      viewablePercentThreshold != null &&\n        (itemVisiblePercentThreshold != null) !==\n          (viewAreaCoveragePercentThreshold != null),\n      'Must set exactly one of itemVisiblePercentThreshold or viewAreaCoveragePercentThreshold',\n    );\n    const viewableIndices = [];\n    if (itemCount === 0) {\n      return viewableIndices;\n    }\n    let firstVisible = -1;\n    const {first, last} = renderRange || {first: 0, last: itemCount - 1};\n    if (last >= itemCount) {\n      console.warn(\n        'Invalid render range computing viewability ' +\n          JSON.stringify({renderRange, itemCount}),\n      );\n      return [];\n    }\n    for (let idx = first; idx <= last; idx++) {\n      const metrics = listMetrics.getCellMetrics(idx, props);\n      if (!metrics) {\n        continue;\n      }\n      const top = Math.floor(metrics.offset - scrollOffset);\n      const bottom = Math.floor(top + metrics.length);\n\n      if (top < viewportHeight && bottom > 0) {\n        firstVisible = idx;\n        if (\n          _isViewable(\n            viewAreaMode,\n            viewablePercentThreshold,\n            top,\n            bottom,\n            viewportHeight,\n            metrics.length,\n          )\n        ) {\n          viewableIndices.push(idx);\n        }\n      } else if (firstVisible >= 0) {\n        break;\n      }\n    }\n    return viewableIndices;\n  }\n\n  /**\n   * Figures out which items are viewable and how that has changed from before and calls\n   * `onViewableItemsChanged` as appropriate.\n   */\n  onUpdate(\n    props                 ,\n    scrollOffset        ,\n    viewportHeight        ,\n    listMetrics                       ,\n    createViewToken   \n                    \n                          \n                             \n                  ,\n    onViewableItemsChanged    \n                                      \n                                \n         \n              ,\n    // Optional optimization to reduce the scan size\n    renderRange    \n                    \n                   \n         \n     ,\n  )       {\n    const itemCount = props.getItemCount(props.data);\n    if (\n      (this._config.waitForInteraction && !this._hasInteracted) ||\n      itemCount === 0 ||\n      !listMetrics.getCellMetrics(0, props)\n    ) {\n      return;\n    }\n    let viewableIndices                = [];\n    if (itemCount) {\n      viewableIndices = this.computeViewableItems(\n        props,\n        scrollOffset,\n        viewportHeight,\n        listMetrics,\n        renderRange,\n      );\n    }\n    if (\n      this._viewableIndices.length === viewableIndices.length &&\n      this._viewableIndices.every((v, ii) => v === viewableIndices[ii])\n    ) {\n      // We might get a lot of scroll events where visibility doesn't change and we don't want to do\n      // extra work in those cases.\n      return;\n    }\n    this._viewableIndices = viewableIndices;\n    if (this._config.minimumViewTime) {\n      const handle            = setTimeout(() => {\n        /* $FlowFixMe[incompatible-call] (>=0.63.0 site=react_native_fb) This\n         * comment suppresses an error found when Flow v0.63 was deployed. To\n         * see the error delete this comment and run Flow. */\n        this._timers.delete(handle);\n        this._onUpdateSync(\n          props,\n          viewableIndices,\n          onViewableItemsChanged,\n          createViewToken,\n        );\n      }, this._config.minimumViewTime);\n      /* $FlowFixMe[incompatible-call] (>=0.63.0 site=react_native_fb) This\n       * comment suppresses an error found when Flow v0.63 was deployed. To see\n       * the error delete this comment and run Flow. */\n      this._timers.add(handle);\n    } else {\n      this._onUpdateSync(\n        props,\n        viewableIndices,\n        onViewableItemsChanged,\n        createViewToken,\n      );\n    }\n  }\n\n  /**\n   * clean-up cached _viewableIndices to evaluate changed items on next update\n   */\n  resetViewableIndices() {\n    this._viewableIndices = [];\n  }\n\n  /**\n   * Records that an interaction has happened even if there has been no scroll.\n   */\n  recordInteraction() {\n    this._hasInteracted = true;\n  }\n\n  _onUpdateSync(\n    props                 ,\n    viewableIndicesToCheck               ,\n    onViewableItemsChanged    \n                                \n                                      \n         \n              ,\n    createViewToken   \n                    \n                          \n                             \n                  ,\n  ) {\n    // Filter out indices that have gone out of view since this call was scheduled.\n    viewableIndicesToCheck = viewableIndicesToCheck.filter(ii =>\n      this._viewableIndices.includes(ii),\n    );\n    const prevItems = this._viewableItems;\n    const nextItems = new Map(\n      viewableIndicesToCheck.map(ii => {\n        const viewable = createViewToken(ii, true, props);\n        return [viewable.key, viewable];\n      }),\n    );\n\n    const changed = [];\n    for (const [key, viewable] of nextItems) {\n      if (!prevItems.has(key)) {\n        changed.push(viewable);\n      }\n    }\n    for (const [key, viewable] of prevItems) {\n      if (!nextItems.has(key)) {\n        changed.push({...viewable, isViewable: false});\n      }\n    }\n    if (changed.length > 0) {\n      this._viewableItems = nextItems;\n      onViewableItemsChanged({\n        viewableItems: Array.from(nextItems.values()),\n        changed,\n        viewabilityConfig: this._config,\n      });\n    }\n  }\n}\n\nfunction _isViewable(\n  viewAreaMode         ,\n  viewablePercentThreshold        ,\n  top        ,\n  bottom        ,\n  viewportHeight        ,\n  itemLength        ,\n)          {\n  if (_isEntirelyVisible(top, bottom, viewportHeight)) {\n    return true;\n  } else {\n    const pixels = _getPixelsVisible(top, bottom, viewportHeight);\n    const percent =\n      100 * (viewAreaMode ? pixels / viewportHeight : pixels / itemLength);\n    return percent >= viewablePercentThreshold;\n  }\n}\n\nfunction _getPixelsVisible(\n  top        ,\n  bottom        ,\n  viewportHeight        ,\n)         {\n  const visibleHeight = Math.min(bottom, viewportHeight) - Math.max(top, 0);\n  return Math.max(0, visibleHeight);\n}\n\nfunction _isEntirelyVisible(\n  top        ,\n  bottom        ,\n  viewportHeight        ,\n)          {\n  return top >= 0 && bottom <= viewportHeight && bottom > top;\n}\n\nmodule.exports = ViewabilityHelper;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *      \n * @format\n */\n\n'use strict';\n\n                                    \n                  \n                                 \n\nimport * as ReactNativeFeatureFlags from 'react-native/src/private/featureflags/ReactNativeFeatureFlags';\n\n/**\n * Used to find the indices of the frames that overlap the given offsets. Useful for finding the\n * items that bound different windows of content, such as the visible area or the buffered overscan\n * area.\n */\nexport function elementsThatOverlapOffsets(\n  offsets               ,\n  props                 ,\n  listMetrics                       ,\n  zoomScale         = 1,\n)                {\n  const itemCount = props.getItemCount(props.data);\n  const result = [];\n  for (let offsetIndex = 0; offsetIndex < offsets.length; offsetIndex++) {\n    const currentOffset = offsets[offsetIndex];\n    let left = 0;\n    let right = itemCount - 1;\n\n    while (left <= right) {\n      const mid = left + Math.floor((right - left) / 2);\n      const frame = listMetrics.getCellMetricsApprox(mid, props);\n      const scaledOffsetStart = frame.offset * zoomScale;\n      const scaledOffsetEnd = (frame.offset + frame.length) * zoomScale;\n\n      // We want the first frame that contains the offset, with inclusive bounds. Thus, for the\n      // first frame the scaledOffsetStart is inclusive, while for other frames it is exclusive.\n      if (\n        (mid === 0 && currentOffset < scaledOffsetStart) ||\n        (mid !== 0 && currentOffset <= scaledOffsetStart)\n      ) {\n        right = mid - 1;\n      } else if (currentOffset > scaledOffsetEnd) {\n        left = mid + 1;\n      } else {\n        result[offsetIndex] = mid;\n        break;\n      }\n    }\n  }\n\n  return result;\n}\n\n/**\n * Computes the number of elements in the `next` range that are new compared to the `prev` range.\n * Handy for calculating how many new items will be rendered when the render window changes so we\n * can restrict the number of new items render at once so that content can appear on the screen\n * faster.\n */\nexport function newRangeCount(\n  prev   \n                  \n                 \n       \n   ,\n  next   \n                  \n                 \n       \n   ,\n)         {\n  return (\n    next.last -\n    next.first +\n    1 -\n    Math.max(\n      0,\n      1 + Math.min(next.last, prev.last) - Math.max(next.first, prev.first),\n    )\n  );\n}\n\n/**\n * Custom logic for determining which items should be rendered given the current frame and scroll\n * metrics, as well as the previous render state. The algorithm may evolve over time, but generally\n * prioritizes the visible area first, then expands that with overscan regions ahead and behind,\n * biased in the direction of scroll.\n */\nexport function computeWindowedRenderLimits(\n  props                 ,\n  maxToRenderPerBatch        ,\n  windowSize        ,\n  prev   \n                  \n                 \n   ,\n  listMetrics                       ,\n  scrollMetrics   \n               \n                   \n                     \n                          \n                      \n       \n   ,\n)   \n                \n               \n  {\n  const itemCount = props.getItemCount(props.data);\n  if (itemCount === 0) {\n    return {first: 0, last: -1};\n  }\n  const {offset, velocity, visibleLength, zoomScale = 1} = scrollMetrics;\n\n  // Start with visible area, then compute maximum overscan region by expanding from there, biased\n  // in the direction of scroll. Total overscan area is capped, which should cap memory consumption\n  // too.\n  const visibleBegin = Math.max(0, offset);\n  const visibleEnd = visibleBegin + visibleLength;\n  const overscanLength = (windowSize - 1) * visibleLength;\n\n  // Considering velocity seems to introduce more churn than it's worth.\n  const leadFactor = 0.5; // Math.max(0, Math.min(1, velocity / 25 + 0.5));\n\n  const fillPreference =\n    velocity > 1 ? 'after' : velocity < -1 ? 'before' : 'none';\n\n  const overscanBegin = Math.max(\n    0,\n    visibleBegin - (1 - leadFactor) * overscanLength,\n  );\n  const overscanEnd = Math.max(0, visibleEnd + leadFactor * overscanLength);\n\n  const lastItemOffset =\n    listMetrics.getCellMetricsApprox(itemCount - 1, props).offset * zoomScale;\n  if (lastItemOffset < overscanBegin) {\n    // Entire list is before our overscan window\n    return {\n      first: Math.max(0, itemCount - 1 - maxToRenderPerBatch),\n      last: itemCount - 1,\n    };\n  }\n\n  // Find the indices that correspond to the items at the render boundaries we're targeting.\n  let [overscanFirst, first, last, overscanLast] = elementsThatOverlapOffsets(\n    [overscanBegin, visibleBegin, visibleEnd, overscanEnd],\n    props,\n    listMetrics,\n    zoomScale,\n  );\n  overscanFirst = overscanFirst == null ? 0 : overscanFirst;\n  first = first == null ? Math.max(0, overscanFirst) : first;\n  overscanLast = overscanLast == null ? itemCount - 1 : overscanLast;\n  last =\n    last == null\n      ? Math.min(overscanLast, first + maxToRenderPerBatch - 1)\n      : last;\n  const visible = {first, last};\n\n  // We want to limit the number of new cells we're rendering per batch so that we can fill the\n  // content on the screen quickly. If we rendered the entire overscan window at once, the user\n  // could be staring at white space for a long time waiting for a bunch of offscreen content to\n  // render.\n  let newCellCount = newRangeCount(prev, visible);\n\n  while (true) {\n    if (first <= overscanFirst && last >= overscanLast) {\n      // If we fill the entire overscan range, we're done.\n      break;\n    }\n    const maxNewCells = newCellCount >= maxToRenderPerBatch;\n\n    let firstWillAddMore;\n    let lastWillAddMore;\n\n    if (ReactNativeFeatureFlags.fixVirtualizeListCollapseWindowSize()) {\n      firstWillAddMore = first <= prev.first;\n      lastWillAddMore = last >= prev.last;\n    } else {\n      firstWillAddMore = first <= prev.first || first > prev.last;\n      lastWillAddMore = last >= prev.last || last < prev.first;\n    }\n\n    const firstShouldIncrement =\n      first > overscanFirst && (!maxNewCells || !firstWillAddMore);\n    const lastShouldIncrement =\n      last < overscanLast && (!maxNewCells || !lastWillAddMore);\n    if (maxNewCells && !firstShouldIncrement && !lastShouldIncrement) {\n      // We only want to stop if we've hit maxNewCells AND we cannot increment first or last\n      // without rendering new items. This let's us preserve as many already rendered items as\n      // possible, reducing render churn and keeping the rendered overscan range as large as\n      // possible.\n      break;\n    }\n    if (\n      firstShouldIncrement &&\n      !(fillPreference === 'after' && lastShouldIncrement && lastWillAddMore)\n    ) {\n      if (firstWillAddMore) {\n        newCellCount++;\n      }\n      first--;\n    }\n    if (\n      lastShouldIncrement &&\n      !(fillPreference === 'before' && firstShouldIncrement && firstWillAddMore)\n    ) {\n      if (lastWillAddMore) {\n        newCellCount++;\n      }\n      last++;\n    }\n  }\n  if (\n    !(\n      last >= first &&\n      first >= 0 &&\n      last < itemCount &&\n      first >= overscanFirst &&\n      last <= overscanLast &&\n      first <= visible.first &&\n      last >= visible.last\n    )\n  ) {\n    throw new Error(\n      'Bad window calculation ' +\n        JSON.stringify({\n          first,\n          last,\n          itemCount,\n          overscanFirst,\n          overscanLast,\n          visible,\n        }),\n    );\n  }\n  return {first, last};\n}\n\nexport function keyExtractor(item     , index        )         {\n  if (typeof item === 'object' && item?.key != null) {\n    return item.key;\n  }\n  if (typeof item === 'object' && item?.id != null) {\n    return item.id;\n  }\n  return String(index);\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *      \n * @format\n */\n\n                                                                              \n                                                   \n             \n       \n        \n                  \n                 \n             \n                                \n                                                                                                 \n                                                                                \n             \n              \n              \n                                                     \n\nimport Batchinator from '../Interaction/Batchinator';\nimport clamp from '../Utilities/clamp';\nimport infoLog from '../Utilities/infoLog';\nimport {CellRenderMask} from './CellRenderMask';\nimport ChildListCollection from './ChildListCollection';\nimport FillRateHelper from './FillRateHelper';\nimport ListMetricsAggregator from './ListMetricsAggregator';\nimport StateSafePureComponent from './StateSafePureComponent';\nimport ViewabilityHelper from './ViewabilityHelper';\nimport CellRenderer from './VirtualizedListCellRenderer';\nimport {\n  VirtualizedListCellContextProvider,\n  VirtualizedListContext,\n  VirtualizedListContextProvider,\n} from './VirtualizedListContext.js';\nimport {\n  horizontalOrDefault,\n  initialNumToRenderOrDefault,\n  maxToRenderPerBatchOrDefault,\n  onEndReachedThresholdOrDefault,\n  onStartReachedThresholdOrDefault,\n  windowSizeOrDefault,\n} from './VirtualizedListProps';\nimport {\n  computeWindowedRenderLimits,\n  keyExtractor as defaultKeyExtractor,\n} from './VirtualizeUtils';\nimport invariant from 'invariant';\nimport nullthrows from 'nullthrows';\nimport * as React from 'react';\nimport {\n  I18nManager,\n  Platform,\n  RefreshControl,\n  ScrollView,\n  StyleSheet,\n  View,\n  findNodeHandle,\n} from 'react-native';\n\n                                                          \n\nconst ON_EDGE_REACHED_EPSILON = 0.001;\n\nlet _usedIndexForKey = false;\nlet _keylessItemComponentName         = '';\n\n                                       \n                                       \n                                  \n                                    \n                              \n       \n             \n     \n  \n\n              \n                             \n                                                     \n                                                                                           \n                               \n                                                                                             \n                                   \n  \n\nfunction getScrollingThreshold(threshold        , visibleLength        ) {\n  return (threshold * visibleLength) / 2;\n}\n\n/**\n * Base implementation for the more convenient [`<FlatList>`](https://reactnative.dev/docs/flatlist)\n * and [`<SectionList>`](https://reactnative.dev/docs/sectionlist) components, which are also better\n * documented. In general, this should only really be used if you need more flexibility than\n * `FlatList` provides, e.g. for use with immutable data instead of plain arrays.\n *\n * Virtualization massively improves memory consumption and performance of large lists by\n * maintaining a finite render window of active items and replacing all items outside of the render\n * window with appropriately sized blank space. The window adapts to scrolling behavior, and items\n * are rendered incrementally with low-pri (after any running interactions) if they are far from the\n * visible area, or with hi-pri otherwise to minimize the potential of seeing blank space.\n *\n * Some caveats:\n *\n * - Internal state is not preserved when content scrolls out of the render window. Make sure all\n *   your data is captured in the item data or external stores like Flux, Redux, or Relay.\n * - This is a `PureComponent` which means that it will not re-render if `props` remain shallow-\n *   equal. Make sure that everything your `renderItem` function depends on is passed as a prop\n *   (e.g. `extraData`) that is not `===` after updates, otherwise your UI may not update on\n *   changes. This includes the `data` prop and parent component state.\n * - In order to constrain memory and enable smooth scrolling, content is rendered asynchronously\n *   offscreen. This means it's possible to scroll faster than the fill rate ands momentarily see\n *   blank content. This is a tradeoff that can be adjusted to suit the needs of each application,\n *   and we are working on improving it behind the scenes.\n * - By default, the list looks for a `key` or `id` prop on each item and uses that for the React key.\n *   Alternatively, you can provide a custom `keyExtractor` prop.\n * - As an effort to remove defaultProps, use helper functions when referencing certain props\n *\n */\nclass VirtualizedList extends StateSafePureComponent               {\n  static contextType                                = VirtualizedListContext;\n\n  // scrollToEnd may be janky without getItemLayout prop\n  scrollToEnd(params                              ) {\n    const animated = params ? params.animated : true;\n    const veryLast = this.props.getItemCount(this.props.data) - 1;\n    if (veryLast < 0) {\n      return;\n    }\n    const frame = this._listMetrics.getCellMetricsApprox(veryLast, this.props);\n    const offset = Math.max(\n      0,\n      frame.offset +\n        frame.length +\n        this._footerLength -\n        this._scrollMetrics.visibleLength,\n    );\n\n    // TODO: consider using `ref.scrollToEnd` directly\n    this.scrollToOffset({animated, offset});\n  }\n\n  // scrollToIndex may be janky without getItemLayout prop\n  scrollToIndex(params   \n                        \n                  \n                        \n                          \n       \n   )             {\n    const {data, getItemCount, getItemLayout, onScrollToIndexFailed} =\n      this.props;\n    const {animated, index, viewOffset, viewPosition} = params;\n    invariant(\n      index >= 0,\n      `scrollToIndex out of range: requested index ${index} but minimum is 0`,\n    );\n    invariant(\n      getItemCount(data) >= 1,\n      `scrollToIndex out of range: item length ${getItemCount(\n        data,\n      )} but minimum is 1`,\n    );\n    invariant(\n      index < getItemCount(data),\n      `scrollToIndex out of range: requested index ${index} is out of 0 to ${\n        getItemCount(data) - 1\n      }`,\n    );\n    if (\n      !getItemLayout &&\n      index > this._listMetrics.getHighestMeasuredCellIndex()\n    ) {\n      invariant(\n        !!onScrollToIndexFailed,\n        'scrollToIndex should be used in conjunction with getItemLayout or onScrollToIndexFailed, ' +\n          'otherwise there is no way to know the location of offscreen indices or handle failures.',\n      );\n      onScrollToIndexFailed({\n        averageItemLength: this._listMetrics.getAverageCellLength(),\n        highestMeasuredFrameIndex:\n          this._listMetrics.getHighestMeasuredCellIndex(),\n        index,\n      });\n      return;\n    }\n    const frame = this._listMetrics.getCellMetricsApprox(\n      Math.floor(index),\n      this.props,\n    );\n    const offset =\n      Math.max(\n        0,\n        this._listMetrics.getCellOffsetApprox(index, this.props) -\n          (viewPosition || 0) *\n            (this._scrollMetrics.visibleLength - frame.length),\n      ) - (viewOffset || 0);\n\n    this.scrollToOffset({offset, animated});\n  }\n\n  // scrollToItem may be janky without getItemLayout prop. Required linear scan through items -\n  // use scrollToIndex instead if possible.\n  scrollToItem(params   \n                        \n               \n                        \n                          \n       \n   ) {\n    const {item} = params;\n    const {data, getItem, getItemCount} = this.props;\n    const itemCount = getItemCount(data);\n    for (let index = 0; index < itemCount; index++) {\n      if (getItem(data, index) === item) {\n        this.scrollToIndex({...params, index});\n        break;\n      }\n    }\n  }\n\n  /**\n   * Scroll to a specific content pixel offset in the list.\n   *\n   * Param `offset` expects the offset to scroll to.\n   * In case of `horizontal` is true, the offset is the x-value,\n   * in any other case the offset is the y-value.\n   *\n   * Param `animated` (`true` by default) defines whether the list\n   * should do an animation while scrolling.\n   */\n  scrollToOffset(params                                            ) {\n    const {animated, offset} = params;\n    const scrollRef = this._scrollRef;\n\n    if (scrollRef == null) {\n      return;\n    }\n\n    if (scrollRef.scrollTo == null) {\n      console.warn(\n        'No scrollTo method provided. This may be because you have two nested ' +\n          'VirtualizedLists with the same orientation, or because you are ' +\n          'using a custom component that does not implement scrollTo.',\n      );\n      return;\n    }\n\n    const {horizontal, rtl} = this._orientation();\n    if (horizontal && rtl && !this._listMetrics.hasContentLength()) {\n      console.warn(\n        'scrollToOffset may not be called in RTL before content is laid out',\n      );\n      return;\n    }\n\n    scrollRef.scrollTo({\n      animated,\n      ...this._scrollToParamsFromOffset(offset),\n    });\n  }\n\n  _scrollToParamsFromOffset(offset        )                           {\n    const {horizontal, rtl} = this._orientation();\n    if (horizontal && rtl) {\n      // Add the visible length of the scrollview so that the offset is right-aligned\n      const cartOffset = this._listMetrics.cartesianOffset(\n        offset + this._scrollMetrics.visibleLength,\n      );\n      return horizontal ? {x: cartOffset} : {y: cartOffset};\n    } else {\n      return horizontal ? {x: offset} : {y: offset};\n    }\n  }\n\n  recordInteraction() {\n    this._nestedChildLists.forEach(childList => {\n      childList.recordInteraction();\n    });\n    this._viewabilityTuples.forEach(t => {\n      t.viewabilityHelper.recordInteraction();\n    });\n    this._updateViewableItems(this.props, this.state.cellsAroundViewport);\n  }\n\n  flashScrollIndicators() {\n    if (this._scrollRef == null) {\n      return;\n    }\n\n    this._scrollRef.flashScrollIndicators();\n  }\n\n  /**\n   * Provides a handle to the underlying scroll responder.\n   * Note that `this._scrollRef` might not be a `ScrollView`, so we\n   * need to check that it responds to `getScrollResponder` before calling it.\n   */\n  getScrollResponder()                       {\n    if (this._scrollRef && this._scrollRef.getScrollResponder) {\n      return this._scrollRef.getScrollResponder();\n    }\n  }\n\n  getScrollableNode()          {\n    if (this._scrollRef && this._scrollRef.getScrollableNode) {\n      return this._scrollRef.getScrollableNode();\n    } else {\n      return findNodeHandle(this._scrollRef);\n    }\n  }\n\n  getScrollRef() \n                                          \n                                     {\n    if (this._scrollRef && this._scrollRef.getScrollRef) {\n      return this._scrollRef.getScrollRef();\n    } else {\n      return this._scrollRef;\n    }\n  }\n\n  setNativeProps(props        ) {\n    if (this._scrollRef) {\n      this._scrollRef.setNativeProps(props);\n    }\n  }\n\n  _getCellKey()         {\n    return this.context?.cellKey || 'rootList';\n  }\n\n  // $FlowFixMe[missing-local-annot]\n  _getScrollMetrics = () => {\n    return this._scrollMetrics;\n  };\n\n  hasMore()          {\n    return this._hasMore;\n  }\n\n  // $FlowFixMe[missing-local-annot]\n  _getOutermostParentListRef = () => {\n    if (this._isNestedWithSameOrientation()) {\n      return this.context.getOutermostParentListRef();\n    } else {\n      return this;\n    }\n  };\n\n  _registerAsNestedChild = (childList   \n                    \n                         \n   )       => {\n    this._nestedChildLists.add(childList.ref, childList.cellKey);\n    if (this._hasInteracted) {\n      childList.ref.recordInteraction();\n    }\n  };\n\n  _unregisterAsNestedChild = (childList                        )       => {\n    this._nestedChildLists.remove(childList.ref);\n  };\n\n  state       ;\n\n  constructor(props       ) {\n    super(props);\n    this._checkProps(props);\n\n    this._fillRateHelper = new FillRateHelper(this._listMetrics);\n    this._updateCellsToRenderBatcher = new Batchinator(\n      this._updateCellsToRender,\n      this.props.updateCellsBatchingPeriod ?? 50,\n    );\n\n    if (this.props.viewabilityConfigCallbackPairs) {\n      this._viewabilityTuples = this.props.viewabilityConfigCallbackPairs.map(\n        pair => ({\n          viewabilityHelper: new ViewabilityHelper(pair.viewabilityConfig),\n          onViewableItemsChanged: pair.onViewableItemsChanged,\n        }),\n      );\n    } else {\n      const {onViewableItemsChanged, viewabilityConfig} = this.props;\n      if (onViewableItemsChanged) {\n        this._viewabilityTuples.push({\n          viewabilityHelper: new ViewabilityHelper(viewabilityConfig),\n          onViewableItemsChanged: onViewableItemsChanged,\n        });\n      }\n    }\n\n    const initialRenderRegion = VirtualizedList._initialRenderRegion(props);\n\n    const minIndexForVisible =\n      this.props.maintainVisibleContentPosition?.minIndexForVisible ?? 0;\n\n    this.state = {\n      cellsAroundViewport: initialRenderRegion,\n      renderMask: VirtualizedList._createRenderMask(props, initialRenderRegion),\n      firstVisibleItemKey:\n        this.props.getItemCount(this.props.data) > minIndexForVisible\n          ? VirtualizedList._getItemKey(this.props, minIndexForVisible)\n          : null,\n      // When we have a non-zero initialScrollIndex, we will receive a\n      // scroll event later so this will prevent the window from updating\n      // until we get a valid offset.\n      pendingScrollUpdateCount:\n        this.props.initialScrollIndex != null &&\n        this.props.initialScrollIndex > 0\n          ? 1\n          : 0,\n    };\n  }\n\n  _checkProps(props       ) {\n    const {onScroll, windowSize, getItemCount, data, initialScrollIndex} =\n      props;\n\n    invariant(\n      // $FlowFixMe[prop-missing]\n      !onScroll || !onScroll.__isNative,\n      'Components based on VirtualizedList must be wrapped with Animated.createAnimatedComponent ' +\n        'to support native onScroll events with useNativeDriver',\n    );\n    invariant(\n      windowSizeOrDefault(windowSize) > 0,\n      'VirtualizedList: The windowSize prop must be present and set to a value greater than 0.',\n    );\n\n    invariant(\n      getItemCount,\n      'VirtualizedList: The \"getItemCount\" prop must be provided',\n    );\n\n    const itemCount = getItemCount(data);\n\n    if (\n      initialScrollIndex != null &&\n      !this._hasTriggeredInitialScrollToIndex &&\n      (initialScrollIndex < 0 ||\n        (itemCount > 0 && initialScrollIndex >= itemCount)) &&\n      !this._hasWarned.initialScrollIndex\n    ) {\n      console.warn(\n        `initialScrollIndex \"${initialScrollIndex}\" is not valid (list has ${itemCount} items)`,\n      );\n      this._hasWarned.initialScrollIndex = true;\n    }\n\n    if (__DEV__ && !this._hasWarned.flexWrap) {\n      // $FlowFixMe[underconstrained-implicit-instantiation]\n      const flatStyles = StyleSheet.flatten(this.props.contentContainerStyle);\n      if (flatStyles != null && flatStyles.flexWrap === 'wrap') {\n        console.warn(\n          '`flexWrap: `wrap`` is not supported with the `VirtualizedList` components.' +\n            'Consider using `numColumns` with `FlatList` instead.',\n        );\n        this._hasWarned.flexWrap = true;\n      }\n    }\n  }\n\n  static _findItemIndexWithKey(\n    props       ,\n    key        ,\n    hint         ,\n  )          {\n    const itemCount = props.getItemCount(props.data);\n    if (hint != null && hint >= 0 && hint < itemCount) {\n      const curKey = VirtualizedList._getItemKey(props, hint);\n      if (curKey === key) {\n        return hint;\n      }\n    }\n    for (let ii = 0; ii < itemCount; ii++) {\n      const curKey = VirtualizedList._getItemKey(props, ii);\n      if (curKey === key) {\n        return ii;\n      }\n    }\n    return null;\n  }\n\n  static _getItemKey(\n    props   \n                          \n                                \n                                          \n         \n     ,\n    index        ,\n  )         {\n    const item = props.getItem(props.data, index);\n    return VirtualizedList._keyExtractor(item, index, props);\n  }\n\n  static _createRenderMask(\n    props       ,\n    cellsAroundViewport                               ,\n    additionalRegions                                                 ,\n  )                 {\n    const itemCount = props.getItemCount(props.data);\n\n    invariant(\n      cellsAroundViewport.first >= 0 &&\n        cellsAroundViewport.last >= cellsAroundViewport.first - 1 &&\n        cellsAroundViewport.last < itemCount,\n      `Invalid cells around viewport \"[${cellsAroundViewport.first}, ${cellsAroundViewport.last}]\" was passed to VirtualizedList._createRenderMask`,\n    );\n\n    const renderMask = new CellRenderMask(itemCount);\n\n    if (itemCount > 0) {\n      const allRegions = [cellsAroundViewport, ...(additionalRegions ?? [])];\n      for (const region of allRegions) {\n        renderMask.addCells(region);\n      }\n\n      // The initially rendered cells are retained as part of the\n      // \"scroll-to-top\" optimization\n      if (props.initialScrollIndex == null || props.initialScrollIndex <= 0) {\n        const initialRegion = VirtualizedList._initialRenderRegion(props);\n        renderMask.addCells(initialRegion);\n      }\n\n      // The layout coordinates of sticker headers may be off-screen while the\n      // actual header is on-screen. Keep the most recent before the viewport\n      // rendered, even if its layout coordinates are not in viewport.\n      const stickyIndicesSet = new Set(props.stickyHeaderIndices);\n      VirtualizedList._ensureClosestStickyHeader(\n        props,\n        stickyIndicesSet,\n        renderMask,\n        cellsAroundViewport.first,\n      );\n    }\n\n    return renderMask;\n  }\n\n  static _initialRenderRegion(props       )                                {\n    const itemCount = props.getItemCount(props.data);\n\n    const firstCellIndex = Math.max(\n      0,\n      Math.min(itemCount - 1, Math.floor(props.initialScrollIndex ?? 0)),\n    );\n\n    const lastCellIndex =\n      Math.min(\n        itemCount,\n        firstCellIndex + initialNumToRenderOrDefault(props.initialNumToRender),\n      ) - 1;\n\n    return {\n      first: firstCellIndex,\n      last: lastCellIndex,\n    };\n  }\n\n  static _ensureClosestStickyHeader(\n    props       ,\n    stickyIndicesSet             ,\n    renderMask                ,\n    cellIdx        ,\n  ) {\n    const stickyOffset = props.ListHeaderComponent ? 1 : 0;\n\n    for (let itemIdx = cellIdx - 1; itemIdx >= 0; itemIdx--) {\n      if (stickyIndicesSet.has(itemIdx + stickyOffset)) {\n        renderMask.addCells({first: itemIdx, last: itemIdx});\n        break;\n      }\n    }\n  }\n\n  _adjustCellsAroundViewport(\n    props       ,\n    cellsAroundViewport                               ,\n    pendingScrollUpdateCount        ,\n  )                                {\n    const {data, getItemCount} = props;\n    const onEndReachedThreshold = onEndReachedThresholdOrDefault(\n      props.onEndReachedThreshold,\n    );\n    const {offset, visibleLength} = this._scrollMetrics;\n    const contentLength = this._listMetrics.getContentLength();\n    const distanceFromEnd = contentLength - visibleLength - offset;\n\n    // Wait until the scroll view metrics have been set up. And until then,\n    // we will trust the initialNumToRender suggestion\n    if (visibleLength <= 0 || contentLength <= 0) {\n      return cellsAroundViewport.last >= getItemCount(data)\n        ? VirtualizedList._constrainToItemCount(cellsAroundViewport, props)\n        : cellsAroundViewport;\n    }\n\n    let newCellsAroundViewport                               ;\n    if (props.disableVirtualization) {\n      const renderAhead =\n        distanceFromEnd < onEndReachedThreshold * visibleLength\n          ? maxToRenderPerBatchOrDefault(props.maxToRenderPerBatch)\n          : 0;\n\n      newCellsAroundViewport = {\n        first: 0,\n        last: Math.min(\n          cellsAroundViewport.last + renderAhead,\n          getItemCount(data) - 1,\n        ),\n      };\n    } else {\n      // If we have a pending scroll update, we should not adjust the render window as it\n      // might override the correct window.\n      if (pendingScrollUpdateCount > 0) {\n        return cellsAroundViewport.last >= getItemCount(data)\n          ? VirtualizedList._constrainToItemCount(cellsAroundViewport, props)\n          : cellsAroundViewport;\n      }\n\n      newCellsAroundViewport = computeWindowedRenderLimits(\n        props,\n        maxToRenderPerBatchOrDefault(props.maxToRenderPerBatch),\n        windowSizeOrDefault(props.windowSize),\n        cellsAroundViewport,\n        this._listMetrics,\n        this._scrollMetrics,\n      );\n      invariant(\n        newCellsAroundViewport.last < getItemCount(data),\n        'computeWindowedRenderLimits() should return range in-bounds',\n      );\n    }\n\n    if (this._nestedChildLists.size() > 0) {\n      // If some cell in the new state has a child list in it, we should only render\n      // up through that item, so that we give that list a chance to render.\n      // Otherwise there's churn from multiple child lists mounting and un-mounting\n      // their items.\n\n      // Will this prevent rendering if the nested list doesn't realize the end?\n      const childIdx = this._findFirstChildWithMore(\n        newCellsAroundViewport.first,\n        newCellsAroundViewport.last,\n      );\n\n      newCellsAroundViewport.last = childIdx ?? newCellsAroundViewport.last;\n    }\n\n    return newCellsAroundViewport;\n  }\n\n  _findFirstChildWithMore(first        , last        )                {\n    for (let ii = first; ii <= last; ii++) {\n      const cellKeyForIndex = this._indicesToKeys.get(ii);\n      if (\n        cellKeyForIndex != null &&\n        this._nestedChildLists.anyInCell(cellKeyForIndex, childList =>\n          childList.hasMore(),\n        )\n      ) {\n        return ii;\n      }\n    }\n\n    return null;\n  }\n\n  componentDidMount() {\n    if (this._isNestedWithSameOrientation()) {\n      this.context.registerAsNestedChild({\n        ref: this,\n        cellKey: this.context.cellKey,\n      });\n    }\n  }\n\n  componentWillUnmount() {\n    if (this._isNestedWithSameOrientation()) {\n      this.context.unregisterAsNestedChild({ref: this});\n    }\n    this._updateCellsToRenderBatcher.dispose();\n    this._viewabilityTuples.forEach(tuple => {\n      tuple.viewabilityHelper.dispose();\n    });\n    this._fillRateHelper.deactivateAndFlush();\n  }\n\n  static getDerivedStateFromProps(newProps       , prevState       )        {\n    // first and last could be stale (e.g. if a new, shorter items props is passed in), so we make\n    // sure we're rendering a reasonable range here.\n    const itemCount = newProps.getItemCount(newProps.data);\n    if (itemCount === prevState.renderMask.numCells()) {\n      return prevState;\n    }\n\n    let maintainVisibleContentPositionAdjustment          = null;\n    const prevFirstVisibleItemKey = prevState.firstVisibleItemKey;\n    const minIndexForVisible =\n      newProps.maintainVisibleContentPosition?.minIndexForVisible ?? 0;\n    const newFirstVisibleItemKey =\n      newProps.getItemCount(newProps.data) > minIndexForVisible\n        ? VirtualizedList._getItemKey(newProps, minIndexForVisible)\n        : null;\n    if (\n      newProps.maintainVisibleContentPosition != null &&\n      prevFirstVisibleItemKey != null &&\n      newFirstVisibleItemKey != null\n    ) {\n      if (newFirstVisibleItemKey !== prevFirstVisibleItemKey) {\n        // Fast path if items were added at the start of the list.\n        const hint =\n          itemCount - prevState.renderMask.numCells() + minIndexForVisible;\n        const firstVisibleItemIndex = VirtualizedList._findItemIndexWithKey(\n          newProps,\n          prevFirstVisibleItemKey,\n          hint,\n        );\n        maintainVisibleContentPositionAdjustment =\n          firstVisibleItemIndex != null\n            ? firstVisibleItemIndex - minIndexForVisible\n            : null;\n      } else {\n        maintainVisibleContentPositionAdjustment = null;\n      }\n    }\n\n    const constrainedCells = VirtualizedList._constrainToItemCount(\n      maintainVisibleContentPositionAdjustment != null\n        ? {\n            first:\n              prevState.cellsAroundViewport.first +\n              maintainVisibleContentPositionAdjustment,\n            last:\n              prevState.cellsAroundViewport.last +\n              maintainVisibleContentPositionAdjustment,\n          }\n        : prevState.cellsAroundViewport,\n      newProps,\n    );\n\n    return {\n      cellsAroundViewport: constrainedCells,\n      renderMask: VirtualizedList._createRenderMask(newProps, constrainedCells),\n      firstVisibleItemKey: newFirstVisibleItemKey,\n      pendingScrollUpdateCount:\n        maintainVisibleContentPositionAdjustment != null\n          ? prevState.pendingScrollUpdateCount + 1\n          : prevState.pendingScrollUpdateCount,\n    };\n  }\n\n  _pushCells(\n    cells               ,\n    stickyHeaderIndices               ,\n    stickyIndicesFromProps             ,\n    first        ,\n    last        ,\n    inversionStyle               ,\n  ) {\n    const {\n      CellRendererComponent,\n      ItemSeparatorComponent,\n      ListHeaderComponent,\n      ListItemComponent,\n      data,\n      debug,\n      getItem,\n      getItemCount,\n      getItemLayout,\n      horizontal,\n      renderItem,\n    } = this.props;\n    const stickyOffset = ListHeaderComponent ? 1 : 0;\n    const end = getItemCount(data) - 1;\n    let prevCellKey;\n    last = Math.min(end, last);\n\n    for (let ii = first; ii <= last; ii++) {\n      const item = getItem(data, ii);\n      const key = VirtualizedList._keyExtractor(item, ii, this.props);\n\n      this._indicesToKeys.set(ii, key);\n      if (stickyIndicesFromProps.has(ii + stickyOffset)) {\n        stickyHeaderIndices.push(cells.length);\n      }\n\n      const shouldListenForLayout =\n        getItemLayout == null || debug || this._fillRateHelper.enabled();\n\n      cells.push(\n        <CellRenderer\n          CellRendererComponent={CellRendererComponent}\n          ItemSeparatorComponent={ii < end ? ItemSeparatorComponent : undefined}\n          ListItemComponent={ListItemComponent}\n          cellKey={key}\n          horizontal={horizontal}\n          index={ii}\n          inversionStyle={inversionStyle}\n          item={item}\n          key={key}\n          prevCellKey={prevCellKey}\n          onUpdateSeparators={this._onUpdateSeparators}\n          onCellFocusCapture={this._onCellFocusCapture}\n          onUnmount={this._onCellUnmount}\n          ref={ref => {\n            this._cellRefs[key] = ref;\n          }}\n          renderItem={renderItem}\n          {...(shouldListenForLayout && {\n            onCellLayout: this._onCellLayout,\n          })}\n        />,\n      );\n      prevCellKey = key;\n    }\n  }\n\n  static _constrainToItemCount(\n    cells                               ,\n    props       ,\n  )                                {\n    const itemCount = props.getItemCount(props.data);\n    const lastPossibleCellIndex = itemCount - 1;\n\n    // Constraining `last` may significantly shrink the window. Adjust `first`\n    // to expand the window if the new `last` results in a new window smaller\n    // than the number of cells rendered per batch.\n    const maxToRenderPerBatch = maxToRenderPerBatchOrDefault(\n      props.maxToRenderPerBatch,\n    );\n    const maxFirst = Math.max(0, lastPossibleCellIndex - maxToRenderPerBatch);\n\n    return {\n      first: clamp(0, cells.first, maxFirst),\n      last: Math.min(lastPossibleCellIndex, cells.last),\n    };\n  }\n\n  _onUpdateSeparators = (keys                , newProps        ) => {\n    keys.forEach(key => {\n      const ref = key != null && this._cellRefs[key];\n      ref && ref.updateSeparatorProps(newProps);\n    });\n  };\n\n  _isNestedWithSameOrientation()          {\n    const nestedContext = this.context;\n    return !!(\n      nestedContext &&\n      !!nestedContext.horizontal === horizontalOrDefault(this.props.horizontal)\n    );\n  }\n\n  _getSpacerKey = (isVertical         )         =>\n    isVertical ? 'height' : 'width';\n\n  static _keyExtractor(\n    item      ,\n    index        ,\n    props   \n                                                            \n         \n     ,\n  )         {\n    if (props.keyExtractor != null) {\n      return props.keyExtractor(item, index);\n    }\n\n    const key = defaultKeyExtractor(item, index);\n    if (key === String(index)) {\n      _usedIndexForKey = true;\n      if (item.type && item.type.displayName) {\n        _keylessItemComponentName = item.type.displayName;\n      }\n    }\n    return key;\n  }\n\n  render()             {\n    this._checkProps(this.props);\n    const {ListEmptyComponent, ListFooterComponent, ListHeaderComponent} =\n      this.props;\n    const {data, horizontal} = this.props;\n    const inversionStyle = this.props.inverted\n      ? horizontalOrDefault(this.props.horizontal)\n        ? styles.horizontallyInverted\n        : styles.verticallyInverted\n      : null;\n    const cells                          = [];\n    const stickyIndicesFromProps = new Set(this.props.stickyHeaderIndices);\n    const stickyHeaderIndices = [];\n\n    // 1. Add cell for ListHeaderComponent\n    if (ListHeaderComponent) {\n      if (stickyIndicesFromProps.has(0)) {\n        stickyHeaderIndices.push(0);\n      }\n      const element = React.isValidElement(ListHeaderComponent) ? (\n        ListHeaderComponent\n      ) : (\n        // $FlowFixMe[not-a-component]\n        // $FlowFixMe[incompatible-type-arg]\n        <ListHeaderComponent />\n      );\n      cells.push(\n        <VirtualizedListCellContextProvider\n          cellKey={this._getCellKey() + '-header'}\n          key=\"$header\">\n          <View\n            // We expect that header component will be a single native view so make it\n            // not collapsable to avoid this view being flattened and make this assumption\n            // no longer true.\n            collapsable={false}\n            onLayout={this._onLayoutHeader}\n            style={StyleSheet.compose(\n              inversionStyle,\n              this.props.ListHeaderComponentStyle,\n            )}>\n            {\n              // $FlowFixMe[incompatible-type] - Typing ReactNativeComponent revealed errors\n              element\n            }\n          </View>\n        </VirtualizedListCellContextProvider>,\n      );\n    }\n\n    // 2a. Add a cell for ListEmptyComponent if applicable\n    const itemCount = this.props.getItemCount(data);\n    if (itemCount === 0 && ListEmptyComponent) {\n      const element                                    = ((React.isValidElement(\n        ListEmptyComponent,\n      ) ? (\n        ListEmptyComponent\n      ) : (\n        // $FlowFixMe[not-a-component]\n        // $FlowFixMe[incompatible-type-arg]\n        <ListEmptyComponent />\n      ))     );\n      cells.push(\n        <VirtualizedListCellContextProvider\n          cellKey={this._getCellKey() + '-empty'}\n          key=\"$empty\">\n          {React.cloneElement(element, {\n            onLayout: (event             ) => {\n              this._onLayoutEmpty(event);\n              // $FlowFixMe[prop-missing] React.Element internal inspection\n              if (element.props.onLayout) {\n                element.props.onLayout(event);\n              }\n            },\n            // $FlowFixMe[prop-missing] React.Element internal inspection\n            style: StyleSheet.compose(inversionStyle, element.props.style),\n          })}\n        </VirtualizedListCellContextProvider>,\n      );\n    }\n\n    // 2b. Add cells and spacers for each item\n    if (itemCount > 0) {\n      _usedIndexForKey = false;\n      _keylessItemComponentName = '';\n      const spacerKey = this._getSpacerKey(!horizontal);\n\n      const renderRegions = this.state.renderMask.enumerateRegions();\n      const lastRegion = renderRegions[renderRegions.length - 1];\n      const lastSpacer = lastRegion?.isSpacer ? lastRegion : null;\n\n      for (const section of renderRegions) {\n        if (section.isSpacer) {\n          // Legacy behavior is to avoid spacers when virtualization is\n          // disabled (including head spacers on initial render).\n          if (this.props.disableVirtualization) {\n            continue;\n          }\n\n          // Without getItemLayout, we limit our tail spacer to the _highestMeasuredFrameIndex to\n          // prevent the user for hyperscrolling into un-measured area because otherwise content will\n          // likely jump around as it renders in above the viewport.\n          const isLastSpacer = section === lastSpacer;\n          const constrainToMeasured = isLastSpacer && !this.props.getItemLayout;\n          const last = constrainToMeasured\n            ? clamp(\n                section.first - 1,\n                section.last,\n                this._listMetrics.getHighestMeasuredCellIndex(),\n              )\n            : section.last;\n\n          const firstMetrics = this._listMetrics.getCellMetricsApprox(\n            section.first,\n            this.props,\n          );\n          const lastMetrics = this._listMetrics.getCellMetricsApprox(\n            last,\n            this.props,\n          );\n          const spacerSize =\n            lastMetrics.offset + lastMetrics.length - firstMetrics.offset;\n          cells.push(\n            <View\n              key={`$spacer-${section.first}`}\n              // $FlowFixMe[incompatible-type]\n              style={{[spacerKey]: spacerSize}}\n            />,\n          );\n        } else {\n          this._pushCells(\n            cells,\n            stickyHeaderIndices,\n            stickyIndicesFromProps,\n            section.first,\n            section.last,\n            inversionStyle,\n          );\n        }\n      }\n\n      if (!this._hasWarned.keys && _usedIndexForKey) {\n        console.warn(\n          'VirtualizedList: missing keys for items, make sure to specify a key or id property on each ' +\n            'item or provide a custom keyExtractor.',\n          _keylessItemComponentName,\n        );\n        this._hasWarned.keys = true;\n      }\n    }\n\n    // 3. Add cell for ListFooterComponent\n    if (ListFooterComponent) {\n      const element = React.isValidElement(ListFooterComponent) ? (\n        ListFooterComponent\n      ) : (\n        // $FlowFixMe[not-a-component]\n        // $FlowFixMe[incompatible-type-arg]\n        <ListFooterComponent />\n      );\n      cells.push(\n        <VirtualizedListCellContextProvider\n          cellKey={this._getFooterCellKey()}\n          key=\"$footer\">\n          <View\n            onLayout={this._onLayoutFooter}\n            style={StyleSheet.compose(\n              inversionStyle,\n              this.props.ListFooterComponentStyle,\n            )}>\n            {\n              // $FlowFixMe[incompatible-type] - Typing ReactNativeComponent revealed errors\n              element\n            }\n          </View>\n        </VirtualizedListCellContextProvider>,\n      );\n    }\n\n    // 4. Render the ScrollView\n    const scrollProps = {\n      ...this.props,\n      onContentSizeChange: this._onContentSizeChange,\n      onLayout: this._onLayout,\n      onScroll: this._onScroll,\n      onScrollBeginDrag: this._onScrollBeginDrag,\n      onScrollEndDrag: this._onScrollEndDrag,\n      onMomentumScrollBegin: this._onMomentumScrollBegin,\n      onMomentumScrollEnd: this._onMomentumScrollEnd,\n      // iOS/macOS requires a non-zero scrollEventThrottle to fire more than a\n      // single notification while scrolling. This will otherwise no-op.\n      scrollEventThrottle: this.props.scrollEventThrottle ?? 0.0001,\n      invertStickyHeaders:\n        this.props.invertStickyHeaders !== undefined\n          ? this.props.invertStickyHeaders\n          : this.props.inverted,\n      stickyHeaderIndices,\n      style: inversionStyle\n        ? [inversionStyle, this.props.style]\n        : this.props.style,\n      isInvertedVirtualizedList: this.props.inverted,\n      maintainVisibleContentPosition:\n        this.props.maintainVisibleContentPosition != null\n          ? {\n              ...this.props.maintainVisibleContentPosition,\n              // Adjust index to account for ListHeaderComponent.\n              minIndexForVisible:\n                this.props.maintainVisibleContentPosition.minIndexForVisible +\n                (this.props.ListHeaderComponent ? 1 : 0),\n            }\n          : undefined,\n    };\n\n    this._hasMore = this.state.cellsAroundViewport.last < itemCount - 1;\n\n    const innerRet = (\n      <VirtualizedListContextProvider\n        value={{\n          cellKey: null,\n          getScrollMetrics: this._getScrollMetrics,\n          horizontal: horizontalOrDefault(this.props.horizontal),\n          getOutermostParentListRef: this._getOutermostParentListRef,\n          registerAsNestedChild: this._registerAsNestedChild,\n          unregisterAsNestedChild: this._unregisterAsNestedChild,\n        }}>\n        {React.cloneElement(\n          (\n            this.props.renderScrollComponent ||\n            this._defaultRenderScrollComponent\n          )(scrollProps),\n          {\n            ref: this._captureScrollRef,\n          },\n          cells,\n        )}\n      </VirtualizedListContextProvider>\n    );\n    let ret             = innerRet;\n    if (__DEV__) {\n      ret = (\n        <ScrollView.Context.Consumer>\n          {scrollContext => {\n            if (\n              scrollContext != null &&\n              !scrollContext.horizontal ===\n                !horizontalOrDefault(this.props.horizontal) &&\n              !this._hasWarned.nesting &&\n              this.context == null &&\n              this.props.scrollEnabled !== false\n            ) {\n              console.error(\n                'VirtualizedLists should never be nested inside plain ScrollViews with the same ' +\n                  'orientation because it can break windowing and other functionality - use another ' +\n                  'VirtualizedList-backed container instead.',\n              );\n              this._hasWarned.nesting = true;\n            }\n            return innerRet;\n          }}\n        </ScrollView.Context.Consumer>\n      );\n    }\n    if (this.props.debug) {\n      return (\n        <View style={styles.debug}>\n          {ret}\n          {this._renderDebugOverlay()}\n        </View>\n      );\n    } else {\n      return ret;\n    }\n  }\n\n  componentDidUpdate(prevProps       ) {\n    const {data, extraData, getItemLayout} = this.props;\n    if (data !== prevProps.data || extraData !== prevProps.extraData) {\n      // clear the viewableIndices cache to also trigger\n      // the onViewableItemsChanged callback with the new data\n      this._viewabilityTuples.forEach(tuple => {\n        tuple.viewabilityHelper.resetViewableIndices();\n      });\n    }\n    // The `this._hiPriInProgress` is guaranteeing a hiPri cell update will only happen\n    // once per fiber update. The `_scheduleCellsToRenderUpdate` will set it to true\n    // if a hiPri update needs to perform. If `componentDidUpdate` is triggered with\n    // `this._hiPriInProgress=true`, means it's triggered by the hiPri update. The\n    // `_scheduleCellsToRenderUpdate` will check this condition and not perform\n    // another hiPri update.\n    const hiPriInProgress = this._hiPriInProgress;\n    this._scheduleCellsToRenderUpdate();\n    // Make sure setting `this._hiPriInProgress` back to false after `componentDidUpdate`\n    // is triggered with `this._hiPriInProgress = true`\n    if (hiPriInProgress) {\n      this._hiPriInProgress = false;\n    }\n\n    // We only call `onEndReached` after we render the last cell, but when\n    // getItemLayout is present, we can scroll past the last rendered cell, and\n    // never trigger a new layout or bounds change, so we need to check again\n    // after rendering more cells.\n    if (getItemLayout != null) {\n      this._maybeCallOnEdgeReached();\n    }\n  }\n\n  _cellRefs                                       = {};\n  _fillRateHelper                ;\n  _listMetrics                        = new ListMetricsAggregator();\n  _footerLength = 0;\n  // Used for preventing scrollToIndex from being called multiple times for initialScrollIndex\n  _hasTriggeredInitialScrollToIndex = false;\n  _hasInteracted = false;\n  _hasMore = false;\n  _hasWarned                      = {};\n  _headerLength = 0;\n  _hiPriInProgress          = false; // flag to prevent infinite hiPri cell limit update\n  _indicesToKeys                      = new Map();\n  _lastFocusedCellKey          = null;\n  _nestedChildLists                                       =\n    new ChildListCollection();\n  _offsetFromParentVirtualizedList         = 0;\n  _pendingViewabilityUpdate          = false;\n  _prevParentOffset         = 0;\n  _scrollMetrics   \n                    \n               \n                   \n                      \n                     \n                          \n                      \n    = {\n    dOffset: 0,\n    dt: 10,\n    offset: 0,\n    timestamp: 0,\n    velocity: 0,\n    visibleLength: 0,\n    zoomScale: 1,\n  };\n  _scrollRef                         = null;\n  _sentStartForContentLength = 0;\n  _sentEndForContentLength = 0;\n  _updateCellsToRenderBatcher             ;\n  _viewabilityTuples                                        = [];\n\n  /* $FlowFixMe[missing-local-annot] The type annotation(s) required by Flow's\n   * LTI update could not be added via codemod */\n  _captureScrollRef = ref => {\n    this._scrollRef = ref;\n  };\n\n  _computeBlankness() {\n    this._fillRateHelper.computeBlankness(\n      this.props,\n      this.state.cellsAroundViewport,\n      this._scrollMetrics,\n    );\n  }\n\n  /* $FlowFixMe[missing-local-annot] The type annotation(s) required by Flow's\n   * LTI update could not be added via codemod */\n  _defaultRenderScrollComponent = props => {\n    const onRefresh = props.onRefresh;\n    if (this._isNestedWithSameOrientation()) {\n      // Prevent VirtualizedList._onContentSizeChange from being triggered by a bubbling onContentSizeChange event.\n      // This could lead to internal inconsistencies within VirtualizedList.\n      const {onContentSizeChange, ...otherProps} = props;\n      return <View {...otherProps} />;\n    } else if (onRefresh) {\n      invariant(\n        typeof props.refreshing === 'boolean',\n        '`refreshing` prop must be set as a boolean in order to use `onRefresh`, but got `' +\n          JSON.stringify(props.refreshing ?? 'undefined') +\n          '`',\n      );\n      return (\n        // $FlowFixMe[prop-missing] Invalid prop usage\n        // $FlowFixMe[incompatible-use]\n        <ScrollView\n          {...props}\n          refreshControl={\n            props.refreshControl == null ? (\n              <RefreshControl\n                // $FlowFixMe[incompatible-type]\n                refreshing={props.refreshing}\n                onRefresh={onRefresh}\n                progressViewOffset={props.progressViewOffset}\n              />\n            ) : (\n              props.refreshControl\n            )\n          }\n        />\n      );\n    } else {\n      // $FlowFixMe[prop-missing] Invalid prop usage\n      // $FlowFixMe[incompatible-use]\n      return <ScrollView {...props} />;\n    }\n  };\n\n  _onCellLayout = (\n    e             ,\n    cellKey        ,\n    cellIndex        ,\n  )       => {\n    const layoutHasChanged = this._listMetrics.notifyCellLayout({\n      cellIndex,\n      cellKey,\n      layout: e.nativeEvent.layout,\n      orientation: this._orientation(),\n    });\n\n    if (layoutHasChanged) {\n      this._scheduleCellsToRenderUpdate();\n    }\n\n    this._triggerRemeasureForChildListsInCell(cellKey);\n    this._computeBlankness();\n    this._updateViewableItems(this.props, this.state.cellsAroundViewport);\n  };\n\n  _onCellFocusCapture = (cellKey        ) => {\n    this._lastFocusedCellKey = cellKey;\n    this._updateCellsToRender();\n  };\n\n  _onCellUnmount = (cellKey        ) => {\n    delete this._cellRefs[cellKey];\n    this._listMetrics.notifyCellUnmounted(cellKey);\n  };\n\n  _triggerRemeasureForChildListsInCell(cellKey        )       {\n    this._nestedChildLists.forEachInCell(cellKey, childList => {\n      childList.measureLayoutRelativeToContainingList();\n    });\n  }\n\n  measureLayoutRelativeToContainingList()       {\n    // TODO (T35574538): findNodeHandle sometimes crashes with \"Unable to find\n    // node on an unmounted component\" during scrolling\n    try {\n      if (!this._scrollRef) {\n        return;\n      }\n      // We are assuming that getOutermostParentListRef().getScrollRef()\n      // is a non-null reference to a ScrollView\n      this._scrollRef.measureLayout(\n        this.context.getOutermostParentListRef().getScrollRef(),\n        (x, y, width, height) => {\n          this._offsetFromParentVirtualizedList = this._selectOffset({x, y});\n          this._listMetrics.notifyListContentLayout({\n            layout: {width, height},\n            orientation: this._orientation(),\n          });\n          const scrollMetrics = this._convertParentScrollMetrics(\n            this.context.getScrollMetrics(),\n          );\n\n          const metricsChanged =\n            this._scrollMetrics.visibleLength !== scrollMetrics.visibleLength ||\n            this._scrollMetrics.offset !== scrollMetrics.offset;\n\n          if (metricsChanged) {\n            this._scrollMetrics.visibleLength = scrollMetrics.visibleLength;\n            this._scrollMetrics.offset = scrollMetrics.offset;\n\n            // If metrics of the scrollView changed, then we triggered remeasure for child list\n            // to ensure VirtualizedList has the right information.\n            this._nestedChildLists.forEach(childList => {\n              childList.measureLayoutRelativeToContainingList();\n            });\n          }\n        },\n        error => {\n          console.warn(\n            \"VirtualizedList: Encountered an error while measuring a list's\" +\n              ' offset from its containing VirtualizedList.',\n          );\n        },\n      );\n    } catch (error) {\n      console.warn(\n        'measureLayoutRelativeToContainingList threw an error',\n        error.stack,\n      );\n    }\n  }\n\n  _onLayout = (e             ) => {\n    if (this._isNestedWithSameOrientation()) {\n      // Need to adjust our scroll metrics to be relative to our containing\n      // VirtualizedList before we can make claims about list item viewability\n      this.measureLayoutRelativeToContainingList();\n    } else {\n      this._scrollMetrics.visibleLength = this._selectLength(\n        e.nativeEvent.layout,\n      );\n    }\n    this.props.onLayout && this.props.onLayout(e);\n    this._scheduleCellsToRenderUpdate();\n    this._maybeCallOnEdgeReached();\n  };\n\n  _onLayoutEmpty = (e             ) => {\n    this.props.onLayout && this.props.onLayout(e);\n  };\n\n  _getFooterCellKey()         {\n    return this._getCellKey() + '-footer';\n  }\n\n  _onLayoutFooter = (e             ) => {\n    this._triggerRemeasureForChildListsInCell(this._getFooterCellKey());\n    this._footerLength = this._selectLength(e.nativeEvent.layout);\n  };\n\n  _onLayoutHeader = (e             ) => {\n    this._headerLength = this._selectLength(e.nativeEvent.layout);\n  };\n\n  // $FlowFixMe[missing-local-annot]\n  _renderDebugOverlay() {\n    const normalize =\n      this._scrollMetrics.visibleLength /\n      (this._listMetrics.getContentLength() || 1);\n    const framesInLayout = [];\n    const itemCount = this.props.getItemCount(this.props.data);\n    for (let ii = 0; ii < itemCount; ii++) {\n      const frame = this._listMetrics.getCellMetricsApprox(ii, this.props);\n      if (frame.isMounted) {\n        framesInLayout.push(frame);\n      }\n    }\n    const windowTop = this._listMetrics.getCellMetricsApprox(\n      this.state.cellsAroundViewport.first,\n      this.props,\n    ).offset;\n    const frameLast = this._listMetrics.getCellMetricsApprox(\n      this.state.cellsAroundViewport.last,\n      this.props,\n    );\n    const windowLen = frameLast.offset + frameLast.length - windowTop;\n    const visTop = this._scrollMetrics.offset;\n    const visLen = this._scrollMetrics.visibleLength;\n\n    return (\n      <View style={[styles.debugOverlayBase, styles.debugOverlay]}>\n        {framesInLayout.map((f, ii) => (\n          <View\n            key={'f' + ii}\n            style={[\n              styles.debugOverlayBase,\n              styles.debugOverlayFrame,\n              {\n                top: f.offset * normalize,\n                height: f.length * normalize,\n              },\n            ]}\n          />\n        ))}\n        <View\n          style={[\n            styles.debugOverlayBase,\n            styles.debugOverlayFrameLast,\n            {\n              top: windowTop * normalize,\n              height: windowLen * normalize,\n            },\n          ]}\n        />\n        <View\n          style={[\n            styles.debugOverlayBase,\n            styles.debugOverlayFrameVis,\n            {\n              top: visTop * normalize,\n              height: visLen * normalize,\n            },\n          ]}\n        />\n      </View>\n    );\n  }\n\n  _selectLength(\n    metrics             \n                     \n                    \n         \n      ,\n  )         {\n    return !horizontalOrDefault(this.props.horizontal)\n      ? metrics.height\n      : metrics.width;\n  }\n\n  _selectOffset({x, y}                                        )         {\n    return this._orientation().horizontal ? x : y;\n  }\n\n  _orientation()                  {\n    return {\n      horizontal: horizontalOrDefault(this.props.horizontal),\n      rtl: I18nManager.isRTL,\n    };\n  }\n\n  _maybeCallOnEdgeReached() {\n    const {\n      data,\n      getItemCount,\n      onStartReached,\n      onStartReachedThreshold,\n      onEndReached,\n      onEndReachedThreshold,\n    } = this.props;\n    // Wait until we have real metrics\n    if (\n      !this._listMetrics.hasContentLength() ||\n      this._scrollMetrics.visibleLength === 0\n    ) {\n      return;\n    }\n\n    // If we have any pending scroll updates it means that the scroll metrics\n    // are out of date and we should not call any of the edge reached callbacks.\n    if (this.state.pendingScrollUpdateCount > 0) {\n      return;\n    }\n\n    const {visibleLength, offset} = this._scrollMetrics;\n    let distanceFromStart = offset;\n    let distanceFromEnd =\n      this._listMetrics.getContentLength() - visibleLength - offset;\n\n    // Especially when oERT is zero it's necessary to 'floor' very small distance values to be 0\n    // since debouncing causes us to not fire this event for every single \"pixel\" we scroll and can thus\n    // be at the edge of the list with a distance approximating 0 but not quite there.\n    if (distanceFromStart < ON_EDGE_REACHED_EPSILON) {\n      distanceFromStart = 0;\n    }\n    if (distanceFromEnd < ON_EDGE_REACHED_EPSILON) {\n      distanceFromEnd = 0;\n    }\n\n    // TODO: T121172172 Look into why we're \"defaulting\" to a threshold of 2px\n    // when oERT is not present (different from 2 viewports used elsewhere)\n    const DEFAULT_THRESHOLD_PX = 2;\n\n    const startThreshold =\n      onStartReachedThreshold != null\n        ? onStartReachedThreshold * visibleLength\n        : DEFAULT_THRESHOLD_PX;\n    const endThreshold =\n      onEndReachedThreshold != null\n        ? onEndReachedThreshold * visibleLength\n        : DEFAULT_THRESHOLD_PX;\n    const isWithinStartThreshold = distanceFromStart <= startThreshold;\n    const isWithinEndThreshold = distanceFromEnd <= endThreshold;\n\n    // First check if the user just scrolled within the end threshold\n    // and call onEndReached only once for a given content length,\n    // and only if onStartReached is not being executed\n    if (\n      onEndReached &&\n      this.state.cellsAroundViewport.last === getItemCount(data) - 1 &&\n      isWithinEndThreshold &&\n      this._listMetrics.getContentLength() !== this._sentEndForContentLength\n    ) {\n      this._sentEndForContentLength = this._listMetrics.getContentLength();\n      onEndReached({distanceFromEnd});\n    }\n\n    // Next check if the user just scrolled within the start threshold\n    // and call onStartReached only once for a given content length,\n    // and only if onEndReached is not being executed\n    if (\n      onStartReached != null &&\n      this.state.cellsAroundViewport.first === 0 &&\n      isWithinStartThreshold &&\n      this._listMetrics.getContentLength() !== this._sentStartForContentLength\n    ) {\n      this._sentStartForContentLength = this._listMetrics.getContentLength();\n      onStartReached({distanceFromStart});\n    }\n\n    // If the user scrolls away from the start or end and back again,\n    // cause onStartReached or onEndReached to be triggered again\n    if (!isWithinStartThreshold) {\n      this._sentStartForContentLength = 0;\n    }\n    if (!isWithinEndThreshold) {\n      this._sentEndForContentLength = 0;\n    }\n  }\n\n  _onContentSizeChange = (width        , height        ) => {\n    this._listMetrics.notifyListContentLayout({\n      layout: {width, height},\n      orientation: this._orientation(),\n    });\n\n    this._maybeScrollToInitialScrollIndex(width, height);\n\n    if (this.props.onContentSizeChange) {\n      this.props.onContentSizeChange(width, height);\n    }\n    this._scheduleCellsToRenderUpdate();\n    this._maybeCallOnEdgeReached();\n  };\n\n  /**\n   * Scroll to a specified `initialScrollIndex` prop after the ScrollView\n   * content has been laid out, if it is still valid. Only a single scroll is\n   * triggered throughout the lifetime of the list.\n   */\n  _maybeScrollToInitialScrollIndex(\n    contentWidth        ,\n    contentHeight        ,\n  ) {\n    if (\n      contentWidth > 0 &&\n      contentHeight > 0 &&\n      this.props.initialScrollIndex != null &&\n      this.props.initialScrollIndex > 0 &&\n      !this._hasTriggeredInitialScrollToIndex\n    ) {\n      if (this.props.contentOffset == null) {\n        if (\n          this.props.initialScrollIndex <\n          this.props.getItemCount(this.props.data)\n        ) {\n          this.scrollToIndex({\n            animated: false,\n            index: nullthrows(this.props.initialScrollIndex),\n          });\n        } else {\n          this.scrollToEnd({animated: false});\n        }\n      }\n      this._hasTriggeredInitialScrollToIndex = true;\n    }\n  }\n\n  /* Translates metrics from a scroll event in a parent VirtualizedList into\n   * coordinates relative to the child list.\n   */\n  _convertParentScrollMetrics = (metrics   \n                          \n                   \n       \n   )             => {\n    // Offset of the top of the nested list relative to the top of its parent's viewport\n    const offset = metrics.offset - this._offsetFromParentVirtualizedList;\n    // Child's visible length is the same as its parent's\n    const visibleLength = metrics.visibleLength;\n    const dOffset = offset - this._scrollMetrics.offset;\n    const contentLength = this._listMetrics.getContentLength();\n\n    return {\n      visibleLength,\n      contentLength,\n      offset,\n      dOffset,\n    };\n  };\n\n  unstable_onScroll(e        ) {\n    this._onScroll(e);\n  }\n\n  _onScroll = (e        ) => {\n    this._nestedChildLists.forEach(childList => {\n      childList._onScroll(e);\n    });\n    if (this.props.onScroll) {\n      this.props.onScroll(e);\n    }\n    const timestamp = e.timeStamp;\n    let visibleLength = this._selectLength(e.nativeEvent.layoutMeasurement);\n    let contentLength = this._selectLength(e.nativeEvent.contentSize);\n    let offset = this._offsetFromScrollEvent(e);\n    let dOffset = offset - this._scrollMetrics.offset;\n\n    if (this._isNestedWithSameOrientation()) {\n      if (this._listMetrics.getContentLength() === 0) {\n        // Ignore scroll events until onLayout has been called and we\n        // know our offset from our offset from our parent\n        return;\n      }\n      ({visibleLength, contentLength, offset, dOffset} =\n        this._convertParentScrollMetrics({\n          visibleLength,\n          offset,\n        }));\n    }\n\n    const dt = this._scrollMetrics.timestamp\n      ? Math.max(1, timestamp - this._scrollMetrics.timestamp)\n      : 1;\n    const velocity = dOffset / dt;\n\n    if (\n      dt > 500 &&\n      this._scrollMetrics.dt > 500 &&\n      contentLength > 5 * visibleLength &&\n      !this._hasWarned.perf\n    ) {\n      infoLog(\n        'VirtualizedList: You have a large list that is slow to update - make sure your ' +\n          'renderItem function renders components that follow React performance best practices ' +\n          'like PureComponent, shouldComponentUpdate, etc.',\n        {dt, prevDt: this._scrollMetrics.dt, contentLength},\n      );\n      this._hasWarned.perf = true;\n    }\n\n    // For invalid negative values (w/ RTL), set this to 1.\n    const zoomScale = e.nativeEvent.zoomScale < 0 ? 1 : e.nativeEvent.zoomScale;\n    this._scrollMetrics = {\n      dt,\n      dOffset,\n      offset,\n      timestamp,\n      velocity,\n      visibleLength,\n      zoomScale,\n    };\n    if (this.state.pendingScrollUpdateCount > 0) {\n      this.setState(state => ({\n        pendingScrollUpdateCount: state.pendingScrollUpdateCount - 1,\n      }));\n    }\n    this._updateViewableItems(this.props, this.state.cellsAroundViewport);\n    if (!this.props) {\n      return;\n    }\n    this._maybeCallOnEdgeReached();\n    if (velocity !== 0) {\n      this._fillRateHelper.activate();\n    }\n    this._computeBlankness();\n    this._scheduleCellsToRenderUpdate();\n  };\n\n  _offsetFromScrollEvent(e             )         {\n    const {contentOffset, contentSize, layoutMeasurement} = e.nativeEvent;\n    const {horizontal, rtl} = this._orientation();\n    if (horizontal && rtl) {\n      return (\n        this._selectLength(contentSize) -\n        (this._selectOffset(contentOffset) +\n          this._selectLength(layoutMeasurement))\n      );\n    } else {\n      return this._selectOffset(contentOffset);\n    }\n  }\n\n  _scheduleCellsToRenderUpdate() {\n    // Only trigger high-priority updates if we've actually rendered cells,\n    // and with that size estimate, accurately compute how many cells we should render.\n    // Otherwise, it would just render as many cells as it can (of zero dimension),\n    // each time through attempting to render more (limited by maxToRenderPerBatch),\n    // starving the renderer from actually laying out the objects and computing _averageCellLength.\n    // If this is triggered in an `componentDidUpdate` followed by a hiPri cellToRenderUpdate\n    // We shouldn't do another hipri cellToRenderUpdate\n    if (\n      (this._listMetrics.getAverageCellLength() > 0 ||\n        this.props.getItemLayout != null) &&\n      this._shouldRenderWithPriority() &&\n      !this._hiPriInProgress\n    ) {\n      this._hiPriInProgress = true;\n      // Don't worry about interactions when scrolling quickly; focus on filling content as fast\n      // as possible.\n      this._updateCellsToRenderBatcher.dispose();\n      this._updateCellsToRender();\n      return;\n    } else {\n      this._updateCellsToRenderBatcher.schedule();\n    }\n  }\n\n  _shouldRenderWithPriority()          {\n    const {first, last} = this.state.cellsAroundViewport;\n    const {offset, visibleLength, velocity} = this._scrollMetrics;\n    const itemCount = this.props.getItemCount(this.props.data);\n    let hiPri = false;\n    const onStartReachedThreshold = onStartReachedThresholdOrDefault(\n      this.props.onStartReachedThreshold,\n    );\n    const onEndReachedThreshold = onEndReachedThresholdOrDefault(\n      this.props.onEndReachedThreshold,\n    );\n    // Mark as high priority if we're close to the start of the first item\n    // But only if there are items before the first rendered item\n    if (first > 0) {\n      const distTop =\n        offset -\n        this._listMetrics.getCellMetricsApprox(first, this.props).offset;\n      hiPri =\n        distTop < 0 ||\n        (velocity < -2 &&\n          distTop <\n            getScrollingThreshold(onStartReachedThreshold, visibleLength));\n    }\n    // Mark as high priority if we're close to the end of the last item\n    // But only if there are items after the last rendered item\n    if (!hiPri && last >= 0 && last < itemCount - 1) {\n      const distBottom =\n        this._listMetrics.getCellMetricsApprox(last, this.props).offset -\n        (offset + visibleLength);\n      hiPri =\n        distBottom < 0 ||\n        (velocity > 2 &&\n          distBottom <\n            getScrollingThreshold(onEndReachedThreshold, visibleLength));\n    }\n\n    return hiPri;\n  }\n\n  unstable_onScrollBeginDrag(e             ) {\n    this._onScrollBeginDrag(e);\n  }\n\n  _onScrollBeginDrag = (e             )       => {\n    this._nestedChildLists.forEach(childList => {\n      childList._onScrollBeginDrag(e);\n    });\n    this._viewabilityTuples.forEach(tuple => {\n      tuple.viewabilityHelper.recordInteraction();\n    });\n    this._hasInteracted = true;\n    this.props.onScrollBeginDrag && this.props.onScrollBeginDrag(e);\n  };\n\n  unstable_onScrollEndDrag(e             ) {\n    this._onScrollEndDrag(e);\n  }\n\n  _onScrollEndDrag = (e             )       => {\n    this._nestedChildLists.forEach(childList => {\n      childList._onScrollEndDrag(e);\n    });\n    const {velocity} = e.nativeEvent;\n    if (velocity) {\n      this._scrollMetrics.velocity = this._selectOffset(velocity);\n    }\n    this._computeBlankness();\n    this.props.onScrollEndDrag && this.props.onScrollEndDrag(e);\n  };\n\n  unstable_onMomentumScrollBegin(e             ) {\n    this._onMomentumScrollBegin(e);\n  }\n\n  _onMomentumScrollBegin = (e             )       => {\n    this._nestedChildLists.forEach(childList => {\n      childList._onMomentumScrollBegin(e);\n    });\n    this.props.onMomentumScrollBegin && this.props.onMomentumScrollBegin(e);\n  };\n\n  unstable_onMomentumScrollEnd(e             ) {\n    this._onMomentumScrollEnd(e);\n  }\n\n  _onMomentumScrollEnd = (e             )       => {\n    this._nestedChildLists.forEach(childList => {\n      childList._onMomentumScrollEnd(e);\n    });\n    this._scrollMetrics.velocity = 0;\n    this._computeBlankness();\n    this.props.onMomentumScrollEnd && this.props.onMomentumScrollEnd(e);\n  };\n\n  _updateCellsToRender = () => {\n    this._updateViewableItems(this.props, this.state.cellsAroundViewport);\n\n    this.setState((state, props) => {\n      const cellsAroundViewport = this._adjustCellsAroundViewport(\n        props,\n        state.cellsAroundViewport,\n        state.pendingScrollUpdateCount,\n      );\n      const renderMask = VirtualizedList._createRenderMask(\n        props,\n        cellsAroundViewport,\n        this._getNonViewportRenderRegions(props),\n      );\n\n      if (\n        cellsAroundViewport.first === state.cellsAroundViewport.first &&\n        cellsAroundViewport.last === state.cellsAroundViewport.last &&\n        renderMask.equals(state.renderMask)\n      ) {\n        return null;\n      }\n\n      return {cellsAroundViewport, renderMask};\n    });\n  };\n\n  _createViewToken = (\n    index        ,\n    isViewable         ,\n    props                 ,\n    // $FlowFixMe[missing-local-annot]\n  ) => {\n    const {data, getItem} = props;\n    const item = getItem(data, index);\n    return {\n      index,\n      item,\n      key: VirtualizedList._keyExtractor(item, index, props),\n      isViewable,\n    };\n  };\n\n  __getListMetrics()                        {\n    return this._listMetrics;\n  }\n\n  _getNonViewportRenderRegions = (\n    props                 ,\n  ) =>                  \n                  \n                 \n        {\n    // Keep a viewport's worth of content around the last focused cell to allow\n    // random navigation around it without any blanking. E.g. tabbing from one\n    // focused item out of viewport to another.\n    if (\n      !(this._lastFocusedCellKey && this._cellRefs[this._lastFocusedCellKey])\n    ) {\n      return [];\n    }\n\n    const lastFocusedCellRenderer = this._cellRefs[this._lastFocusedCellKey];\n    const focusedCellIndex = lastFocusedCellRenderer.props.index;\n    const itemCount = props.getItemCount(props.data);\n\n    // The last cell we rendered may be at a new index. Bail if we don't know\n    // where it is.\n    if (\n      focusedCellIndex >= itemCount ||\n      VirtualizedList._getItemKey(props, focusedCellIndex) !==\n        this._lastFocusedCellKey\n    ) {\n      return [];\n    }\n\n    let first = focusedCellIndex;\n    let heightOfCellsBeforeFocused = 0;\n    for (\n      let i = first - 1;\n      i >= 0 && heightOfCellsBeforeFocused < this._scrollMetrics.visibleLength;\n      i--\n    ) {\n      first--;\n      heightOfCellsBeforeFocused += this._listMetrics.getCellMetricsApprox(\n        i,\n        props,\n      ).length;\n    }\n\n    let last = focusedCellIndex;\n    let heightOfCellsAfterFocused = 0;\n    for (\n      let i = last + 1;\n      i < itemCount &&\n      heightOfCellsAfterFocused < this._scrollMetrics.visibleLength;\n      i++\n    ) {\n      last++;\n      heightOfCellsAfterFocused += this._listMetrics.getCellMetricsApprox(\n        i,\n        props,\n      ).length;\n    }\n\n    return [{first, last}];\n  };\n\n  _updateViewableItems(\n    props                 ,\n    cellsAroundViewport                               ,\n  ) {\n    // If we have any pending scroll updates it means that the scroll metrics\n    // are out of date and we should not call any of the visibility callbacks.\n    if (this.state.pendingScrollUpdateCount > 0) {\n      return;\n    }\n    this._viewabilityTuples.forEach(tuple => {\n      tuple.viewabilityHelper.onUpdate(\n        props,\n        this._scrollMetrics.offset,\n        this._scrollMetrics.visibleLength,\n        this._listMetrics,\n        this._createViewToken,\n        tuple.onViewableItemsChanged,\n        cellsAroundViewport,\n      );\n    });\n  }\n}\n\nconst styles = StyleSheet.create({\n  verticallyInverted:\n    Platform.OS === 'android'\n      ? {transform: [{scale: -1}]}\n      : {transform: [{scaleY: -1}]},\n  horizontallyInverted: {\n    transform: [{scaleX: -1}],\n  },\n  debug: {\n    flex: 1,\n  },\n  debugOverlayBase: {\n    position: 'absolute',\n    top: 0,\n    right: 0,\n  },\n  debugOverlay: {\n    bottom: 0,\n    width: 20,\n    borderColor: 'blue',\n    borderWidth: 1,\n  },\n  debugOverlayFrame: {\n    left: 0,\n    backgroundColor: 'orange',\n  },\n  debugOverlayFrameLast: {\n    left: 0,\n    borderColor: 'green',\n    borderWidth: 2,\n  },\n  debugOverlayFrameVis: {\n    left: 0,\n    borderColor: 'red',\n    borderWidth: 2,\n  },\n});\n\nmodule.exports = VirtualizedList;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *      \n * @format\n */\n\n                                                                              \n                                                                                \n             \n             \n              \n                                                     \n\nimport {VirtualizedListCellContextProvider} from './VirtualizedListContext.js';\nimport invariant from 'invariant';\nimport * as React from 'react';\nimport {StyleSheet, View} from 'react-native';\n\n                            \n                                                                         \n                                               \n                                                      \n    \n                                                                       \n                  \n                       \n                \n                                \n              \n                                                                              \n                                                 \n                                       \n                       \n                             \n                                          \n            \n                       \n                                      \n     \n  \n\n                                         \n                       \n                      \n    \n\n                     \n                                        \n     \n  \n\nexport default class CellRenderer        extends React.PureComponent \n               \n               \n  {\n  state               = {\n    separatorProps: {\n      highlighted: false,\n      leadingItem: this.props.item,\n    },\n  };\n\n  static getDerivedStateFromProps(\n    props              ,\n    prevState              ,\n  )                {\n    if (props.item !== prevState.separatorProps.leadingItem) {\n      return {\n        separatorProps: {\n          ...prevState.separatorProps,\n          leadingItem: props.item,\n        },\n      };\n    }\n    return null;\n  }\n\n  // TODO: consider factoring separator stuff out of VirtualizedList into FlatList since it's not\n  // reused by SectionList and we can keep VirtualizedList simpler.\n  // $FlowFixMe[missing-local-annot]\n  _separators = {\n    highlight: () => {\n      const {cellKey, prevCellKey} = this.props;\n      this.props.onUpdateSeparators([cellKey, prevCellKey], {\n        highlighted: true,\n      });\n    },\n    unhighlight: () => {\n      const {cellKey, prevCellKey} = this.props;\n      this.props.onUpdateSeparators([cellKey, prevCellKey], {\n        highlighted: false,\n      });\n    },\n    updateProps: (\n      select                        ,\n      newProps                       ,\n    ) => {\n      const {cellKey, prevCellKey} = this.props;\n      this.props.onUpdateSeparators(\n        [select === 'leading' ? prevCellKey : cellKey],\n        newProps,\n      );\n    },\n  };\n\n  updateSeparatorProps(newProps                       ) {\n    this.setState(state => ({\n      separatorProps: {...state.separatorProps, ...newProps},\n    }));\n  }\n\n  componentWillUnmount() {\n    this.props.onUnmount(this.props.cellKey);\n  }\n\n  _onLayout = (nativeEvent             )       => {\n    this.props.onCellLayout?.(\n      nativeEvent,\n      this.props.cellKey,\n      this.props.index,\n    );\n  };\n\n  _onCellFocusCapture = (e            )       => {\n    this.props.onCellFocusCapture?.(this.props.cellKey);\n  };\n\n  _renderElement(\n    renderItem                        ,\n    ListItemComponent     ,\n    item       ,\n    index        ,\n  )             {\n    if (renderItem && ListItemComponent) {\n      console.warn(\n        'VirtualizedList: Both ListItemComponent and renderItem props are present. ListItemComponent will take' +\n          ' precedence over renderItem.',\n      );\n    }\n\n    if (ListItemComponent) {\n      return (\n        <ListItemComponent\n          item={item}\n          index={index}\n          separators={this._separators}\n        />\n      );\n    }\n\n    if (renderItem) {\n      return renderItem({\n        item,\n        index,\n        separators: this._separators,\n      });\n    }\n\n    invariant(\n      false,\n      'VirtualizedList: Either ListItemComponent or renderItem props are required but none were found.',\n    );\n  }\n\n  render()             {\n    const {\n      CellRendererComponent,\n      ItemSeparatorComponent,\n      ListItemComponent,\n      cellKey,\n      horizontal,\n      item,\n      index,\n      inversionStyle,\n      onCellLayout,\n      renderItem,\n    } = this.props;\n    const element = this._renderElement(\n      renderItem,\n      ListItemComponent,\n      item,\n      index,\n    );\n\n    // NOTE: that when this is a sticky header, `onLayout` will get automatically extracted and\n    // called explicitly by `ScrollViewStickyHeader`.\n    const itemSeparator             = React.isValidElement(\n      ItemSeparatorComponent,\n    )\n      ? // $FlowFixMe[incompatible-type]\n        ItemSeparatorComponent\n      : // $FlowFixMe[incompatible-type]\n        ItemSeparatorComponent && (\n          <ItemSeparatorComponent {...this.state.separatorProps} />\n        );\n    const cellStyle = inversionStyle\n      ? horizontal\n        ? [styles.rowReverse, inversionStyle]\n        : [styles.columnReverse, inversionStyle]\n      : horizontal\n        ? [styles.row, inversionStyle]\n        : inversionStyle;\n    const result = !CellRendererComponent ? (\n      <View\n        style={cellStyle}\n        onFocusCapture={this._onCellFocusCapture}\n        {...(onCellLayout && {onLayout: this._onLayout})}>\n        {element}\n        {itemSeparator}\n      </View>\n    ) : (\n      <CellRendererComponent\n        cellKey={cellKey}\n        index={index}\n        item={item}\n        style={cellStyle}\n        onFocusCapture={this._onCellFocusCapture}\n        {...(onCellLayout && {onLayout: this._onLayout})}>\n        {element}\n        {itemSeparator}\n      </CellRendererComponent>\n    );\n\n    return (\n      <VirtualizedListCellContextProvider cellKey={this.props.cellKey}>\n        {result}\n      </VirtualizedListCellContextProvider>\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  row: {\n    flexDirection: 'row',\n  },\n  rowReverse: {\n    flexDirection: 'row-reverse',\n  },\n  columnReverse: {\n    flexDirection: 'column-reverse',\n  },\n});\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *       strict-local\n * @format\n */\n\n                                                       \n\nimport * as React from 'react';\nimport {useContext, useMemo} from 'react';\n\n                          \n                   \n                           \n                          \n                    \n               \n                   \n                      \n                     \n                          \n                      \n    \n                       \n                                                                     \n                           \n                    \n                                           \n             \n                                                                              \n   \n\nexport const VirtualizedListContext                          =\n  React.createContext(null);\nif (__DEV__) {\n  VirtualizedListContext.displayName = 'VirtualizedListContext';\n}\n\n/**\n * Resets the context. Intended for use by portal-like components (e.g. Modal).\n */\nexport function VirtualizedListContextResetter({\n  children,\n}   \n                       \n )             {\n  return (\n    <VirtualizedListContext.Provider value={null}>\n      {children}\n    </VirtualizedListContext.Provider>\n  );\n}\n\n/**\n * Sets the context with memoization. Intended to be used by `VirtualizedList`.\n */\nexport function VirtualizedListContextProvider({\n  children,\n  value,\n}   \n                       \n                 \n )             {\n  // Avoid setting a newly created context object if the values are identical.\n  const context = useMemo(\n    () => ({\n      cellKey: null,\n      getScrollMetrics: value.getScrollMetrics,\n      horizontal: value.horizontal,\n      getOutermostParentListRef: value.getOutermostParentListRef,\n      registerAsNestedChild: value.registerAsNestedChild,\n      unregisterAsNestedChild: value.unregisterAsNestedChild,\n    }),\n    [\n      value.getScrollMetrics,\n      value.horizontal,\n      value.getOutermostParentListRef,\n      value.registerAsNestedChild,\n      value.unregisterAsNestedChild,\n    ],\n  );\n  return (\n    <VirtualizedListContext.Provider value={context}>\n      {children}\n    </VirtualizedListContext.Provider>\n  );\n}\n\n/**\n * Sets the `cellKey`. Intended to be used by `VirtualizedList` for each cell.\n */\nexport function VirtualizedListCellContextProvider({\n  cellKey,\n  children,\n}   \n                  \n                       \n )             {\n  // Avoid setting a newly created context object if the values are identical.\n  const currContext = useContext(VirtualizedListContext);\n  const context = useMemo(\n    () => (currContext == null ? null : {...currContext, cellKey}),\n    [currContext, cellKey],\n  );\n  return (\n    <VirtualizedListContext.Provider value={context}>\n      {children}\n    </VirtualizedListContext.Provider>\n  );\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *      \n * @format\n */\n\n             \n                    \n                                \n            \n                             \n                                                                                \n             \n             \n              \n                                                     \n\nimport * as React from 'react';\nimport {                 } from 'react-native';\n\n                       \n\n                          \n                        \n                          \n                                                                          \n     \n  \n\n                                      \n              \n                \n                         \n     \n  \n\n                                                  \n                  \n                       \n                \n              \n                                               \n                                          \n                       \n   \n\n                                     \n                               \n                \n\n                       \n     \n                                                                                                              \n                                                                                    \n     \n             \n     \n                                                                          \n     \n                                               \n     \n                                                    \n     \n                                      \n   \n                       \n                                     \n     \n                                                                                                \n                                                     \n     \n                   \n     \n                                                                                                    \n                                                                                                    \n                                                    \n     \n                                   \n     \n                                                                                                  \n                                                                                               \n                                                       \n     \n                  \n                   \n                   \n              \n                  \n        \n                   \n                   \n                  \n       \n    \n                        \n     \n                                                                                                    \n                                                                                                   \n                                                               \n     \n                               \n     \n                                                                                            \n                                                                                              \n                                                                                               \n                                       \n     \n                               \n     \n                                                                   \n     \n                      \n                                                        \n     \n                                                                   \n                                                                      \n                                                                           \n                                                       \n     \n                                                                        \n     \n                                                                                               \n                                                                                                 \n                                                                                     \n                              \n     \n                                                     \n     \n                                                                           \n    \n                  \n                                                                                    \n                                                                               \n             \n                                                       \n                                                       \n                                \n                                                  \n                                                    \n                                                       \n                                                        \n                                          \n                      \n                                  \n             \n           \n    \n                                                                                        \n                                                                                                \n                                                                                            \n                                                                                                   \n                   \n     \n                        \n                              \n                                       \n    \n     \n                                                                                           \n                        \n     \n                         \n                              \n                                       \n    \n     \n                                                                                                   \n                        \n     \n                          \n                              \n                                       \n    \n     \n                                                      \n     \n                                           \n     \n                                                                                                \n                        \n     \n                          \n                              \n                                       \n    \n     \n                                                      \n     \n                                           \n     \n                                                                                                 \n                                                                                                \n                                                                    \n     \n                                \n     \n                                                                                    \n                                      \n     \n                                                                 \n     \n                                                                                           \n                                                                                     \n                                                                                    \n                                                \n     \n                                  \n     \n                                                                                                   \n                                                      \n     \n                          \n     \n                                                                                                   \n                                                                                                    \n                                                        \n     \n                                   \n                  \n                                      \n                              \n       \n             \n     \n                                                                                      \n                                        \n     \n                                                                     \n     \n                                                                                            \n                                                                                         \n                                                                                        \n                                                \n     \n                                    \n     \n                                                                   \n                              \n     \n                                    \n                                    \n                              \n       \n             \n                                 \n     \n                                                                                \n     \n                              \n     \n                                                                         \n                                                                              \n                                                                     \n     \n                                                      \n     \n                                                             \n     \n                        \n     \n                                                                                        \n    \n                                                         \n     \n                                  \n     \n                                                                                       \n     \n                                                                               \n     \n                                                                                                  \n                                                                                \n     \n                                      \n     \n                                                                     \n     \n                                        \n     \n                                                                                              \n                                                                                  \n     \n                                                                        \n     \n                                                                                             \n                                                                                                 \n                                                                                                   \n                                                                                                  \n                                                                                       \n     \n                       \n     \n                                                      \n     \n                               \n   \n\n                      \n                                     \n                   \n                   \n   \n\n/**\n * Default Props Helper Functions\n * Use the following helper functions for default values\n */\n\n// horizontalOrDefault(this.props.horizontal)\nexport function horizontalOrDefault(horizontal          )          {\n  return horizontal ?? false;\n}\n\n// initialNumToRenderOrDefault(this.props.initialNumToRender)\nexport function initialNumToRenderOrDefault(\n  initialNumToRender         ,\n)         {\n  return initialNumToRender ?? 10;\n}\n\n// maxToRenderPerBatchOrDefault(this.props.maxToRenderPerBatch)\nexport function maxToRenderPerBatchOrDefault(\n  maxToRenderPerBatch         ,\n)         {\n  return maxToRenderPerBatch ?? 10;\n}\n\n// onStartReachedThresholdOrDefault(this.props.onStartReachedThreshold)\nexport function onStartReachedThresholdOrDefault(\n  onStartReachedThreshold         ,\n)         {\n  return onStartReachedThreshold ?? 2;\n}\n\n// onEndReachedThresholdOrDefault(this.props.onEndReachedThreshold)\nexport function onEndReachedThresholdOrDefault(\n  onEndReachedThreshold         ,\n)         {\n  return onEndReachedThreshold ?? 2;\n}\n\n// windowSizeOrDefault(this.props.windowSize)\nexport function windowSizeOrDefault(windowSize         )         {\n  return windowSize ?? 21;\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *      \n * @format\n */\n\n                                                   \n\nimport VirtualizedList from './VirtualizedList';\nimport {keyExtractor as defaultKeyExtractor} from './VirtualizeUtils';\nimport invariant from 'invariant';\nimport * as React from 'react';\n                \n\n                                         \n     \n                                                  \n     \n                                     \n     \n                                                                                                  \n                                             \n     \n               \n                                                                        \n                        \n                       \n                  \n                                       \n                 \n                            \n                              \n                                                                              \n         \n      \n       \n                                  \n                                                     \n                                                                 \n     \n  \n\n                                                   \n                                     \n   \n\n                                                   \n     \n                                                      \n     \n                       \n               \n                  \n                      \n                 \n                            \n                              \n                                                                              \n         \n      \n       \n                          \n     \n                                                                                                  \n                                            \n     \n                                                                               \n     \n                                            \n     \n                                                                               \n     \n                                                                                \n                                                                                                   \n                                                                                                \n                                                                                                 \n                                                        \n     \n                                                        \n     \n                                                                                                \n                                                                           \n     \n                                        \n                                                           \n   \n\n                                                                        \n\n                                \n                             \n                             \n           \n                         \n     \n                                                                    \n                                                        \n         \n      \n    \n   \n                                           \n                      \n                    \n                       \n                      \n                        \n   \n\n                                                     \n\n/**\n * Right now this just flattens everything into one list and uses VirtualizedList under the\n * hood. The only operation that might not scale well is concatting the data arrays of all the\n * sections when new props are received, which should be plenty fast for up to ~10,000 items.\n */\nclass VirtualizedSectionList \n                             \n  extends React.PureComponent                         {\n  scrollToLocation(params                            ) {\n    let index = params.itemIndex;\n    for (let i = 0; i < params.sectionIndex; i++) {\n      index += this.props.getItemCount(this.props.sections[i].data) + 2;\n    }\n    let viewOffset = params.viewOffset || 0;\n    if (this._listRef == null) {\n      return;\n    }\n    const listRef = this._listRef;\n    if (params.itemIndex > 0 && this.props.stickySectionHeadersEnabled) {\n      const frame = listRef\n        .__getListMetrics()\n        .getCellMetricsApprox(index - params.itemIndex, listRef.props);\n      viewOffset += frame.length;\n    }\n    const toIndexParams = {\n      ...params,\n      viewOffset,\n      index,\n    };\n    // $FlowFixMe[incompatible-use]\n    this._listRef.scrollToIndex(toIndexParams);\n  }\n\n  getListRef()                   {\n    return this._listRef;\n  }\n\n  render()             {\n    const {\n      ItemSeparatorComponent, // don't pass through, rendered with renderItem\n      SectionSeparatorComponent,\n      renderItem: _renderItem,\n      renderSectionFooter,\n      renderSectionHeader,\n      sections: _sections,\n      stickySectionHeadersEnabled,\n      ...passThroughProps\n    } = this.props;\n\n    const listHeaderOffset = this.props.ListHeaderComponent ? 1 : 0;\n\n    const stickyHeaderIndices = this.props.stickySectionHeadersEnabled\n      ? ([]               )\n      : undefined;\n\n    let itemCount = 0;\n    for (const section of this.props.sections) {\n      // Track the section header indices\n      if (stickyHeaderIndices != null) {\n        stickyHeaderIndices.push(itemCount + listHeaderOffset);\n      }\n\n      // Add two for the section header and footer.\n      itemCount += 2;\n      itemCount += this.props.getItemCount(section.data);\n    }\n    const renderItem = this._renderItem(itemCount);\n\n    return (\n      <VirtualizedList\n        {...passThroughProps}\n        keyExtractor={this._keyExtractor}\n        stickyHeaderIndices={stickyHeaderIndices}\n        renderItem={renderItem}\n        data={this.props.sections}\n        getItem={(sections, index) =>\n          this._getItem(this.props, sections, index)\n        }\n        getItemCount={() => itemCount}\n        onViewableItemsChanged={\n          this.props.onViewableItemsChanged\n            ? this._onViewableItemsChanged\n            : undefined\n        }\n        ref={this._captureRef}\n      />\n    );\n  }\n\n  _getItem(\n    props                 ,\n    sections                       ,\n    index        ,\n  )        {\n    if (!sections) {\n      return null;\n    }\n    let itemIdx = index - 1;\n    for (let i = 0; i < sections.length; i++) {\n      const section = sections[i];\n      const sectionData = section.data;\n      const itemCount = props.getItemCount(sectionData);\n      if (itemIdx === -1 || itemIdx === itemCount) {\n        // We intend for there to be overflow by one on both ends of the list.\n        // This will be for headers and footers. When returning a header or footer\n        // item the section itself is the item.\n        return section;\n      } else if (itemIdx < itemCount) {\n        // If we are in the bounds of the list's data then return the item.\n        return props.getItem(sectionData, itemIdx);\n      } else {\n        itemIdx -= itemCount + 2; // Add two for the header and footer\n      }\n    }\n    return null;\n  }\n\n  // $FlowFixMe[missing-local-annot]\n  _keyExtractor = (item      , index        ) => {\n    const info = this._subExtractor(index);\n    return (info && info.key) || String(index);\n  };\n\n  _subExtractor(index        )    \n                      \n                                                            \n                \n                                        \n                   \n                                         \n                      \n                        \n                               \n                         \n                                \n       \n    {\n    let itemIndex = index;\n    const {getItem, getItemCount, keyExtractor, sections} = this.props;\n    for (let i = 0; i < sections.length; i++) {\n      const section = sections[i];\n      const sectionData = section.data;\n      const key = section.key || String(i);\n      itemIndex -= 1; // The section adds an item for the header\n      if (itemIndex >= getItemCount(sectionData) + 1) {\n        itemIndex -= getItemCount(sectionData) + 1; // The section adds an item for the footer.\n      } else if (itemIndex === -1) {\n        return {\n          section,\n          key: key + ':header',\n          index: null,\n          header: true,\n          trailingSection: sections[i + 1],\n        };\n      } else if (itemIndex === getItemCount(sectionData)) {\n        return {\n          section,\n          key: key + ':footer',\n          index: null,\n          header: false,\n          trailingSection: sections[i + 1],\n        };\n      } else {\n        const extractor =\n          section.keyExtractor || keyExtractor || defaultKeyExtractor;\n        return {\n          section,\n          key:\n            key + ':' + extractor(getItem(sectionData, itemIndex), itemIndex),\n          index: itemIndex,\n          leadingItem: getItem(sectionData, itemIndex - 1),\n          leadingSection: sections[i - 1],\n          trailingItem: getItem(sectionData, itemIndex + 1),\n          trailingSection: sections[i + 1],\n        };\n      }\n    }\n  }\n\n  _convertViewable = (viewable           )             => {\n    invariant(viewable.index != null, 'Received a broken ViewToken');\n    const info = this._subExtractor(viewable.index);\n    if (!info) {\n      return null;\n    }\n    const keyExtractorWithNullableIndex = info.section.keyExtractor;\n    const keyExtractorWithNonNullableIndex =\n      this.props.keyExtractor || defaultKeyExtractor;\n    const key =\n      keyExtractorWithNullableIndex != null\n        ? keyExtractorWithNullableIndex(viewable.item, info.index)\n        : keyExtractorWithNonNullableIndex(viewable.item, info.index ?? 0);\n\n    return {\n      ...viewable,\n      index: info.index,\n      key,\n      section: info.section,\n    };\n  };\n\n  _onViewableItemsChanged = ({\n    viewableItems,\n    changed,\n  }   \n                                    \n                              \n       \n   ) => {\n    const onViewableItemsChanged = this.props.onViewableItemsChanged;\n    if (onViewableItemsChanged != null) {\n      onViewableItemsChanged({\n        viewableItems: viewableItems\n          .map(this._convertViewable, this)\n          .filter(Boolean),\n        changed: changed.map(this._convertViewable, this).filter(Boolean),\n      });\n    }\n  };\n\n  _renderItem =\n    (listItemCount        )             =>\n    // eslint-disable-next-line react/no-unstable-nested-components\n    ({item, index}                                  ) => {\n      const info = this._subExtractor(index);\n      if (!info) {\n        return null;\n      }\n      const infoIndex = info.index;\n      if (infoIndex == null) {\n        const {section} = info;\n        if (info.header === true) {\n          const {renderSectionHeader} = this.props;\n          return renderSectionHeader ? renderSectionHeader({section}) : null;\n        } else {\n          const {renderSectionFooter} = this.props;\n          return renderSectionFooter ? renderSectionFooter({section}) : null;\n        }\n      } else {\n        const renderItem = info.section.renderItem || this.props.renderItem;\n        const SeparatorComponent = this._getSeparatorComponent(\n          index,\n          info,\n          listItemCount,\n        );\n        invariant(renderItem, 'no renderItem!');\n        return (\n          <ItemWithSeparator\n            SeparatorComponent={SeparatorComponent}\n            LeadingSeparatorComponent={\n              infoIndex === 0 ? this.props.SectionSeparatorComponent : undefined\n            }\n            cellKey={info.key}\n            index={infoIndex}\n            item={item}\n            leadingItem={info.leadingItem}\n            leadingSection={info.leadingSection}\n            prevCellKey={(this._subExtractor(index - 1) || {}).key}\n            // Callback to provide updateHighlight for this item\n            setSelfHighlightCallback={this._setUpdateHighlightFor}\n            setSelfUpdatePropsCallback={this._setUpdatePropsFor}\n            // Provide child ability to set highlight/updateProps for previous item using prevCellKey\n            updateHighlightFor={this._updateHighlightFor}\n            updatePropsFor={this._updatePropsFor}\n            renderItem={renderItem}\n            section={info.section}\n            trailingItem={info.trailingItem}\n            trailingSection={info.trailingSection}\n            inverted={!!this.props.inverted}\n          />\n        );\n      }\n    };\n\n  _updatePropsFor = (cellKey        , value     ) => {\n    const updateProps = this._updatePropsMap[cellKey];\n    if (updateProps != null) {\n      updateProps(value);\n    }\n  };\n\n  _updateHighlightFor = (cellKey        , value         ) => {\n    const updateHighlight = this._updateHighlightMap[cellKey];\n    if (updateHighlight != null) {\n      updateHighlight(value);\n    }\n  };\n\n  _setUpdateHighlightFor = (\n    cellKey        ,\n    updateHighlightFn                    ,\n  ) => {\n    if (updateHighlightFn != null) {\n      this._updateHighlightMap[cellKey] = updateHighlightFn;\n    } else {\n      // $FlowFixMe[prop-missing]\n      delete this._updateHighlightFor[cellKey];\n    }\n  };\n\n  _setUpdatePropsFor = (cellKey        , updatePropsFn                    ) => {\n    if (updatePropsFn != null) {\n      this._updatePropsMap[cellKey] = updatePropsFn;\n    } else {\n      delete this._updatePropsMap[cellKey];\n    }\n  };\n\n  _getSeparatorComponent(\n    index        ,\n    info          ,\n    listItemCount        ,\n  )                            {\n    info = info || this._subExtractor(index);\n    if (!info) {\n      return null;\n    }\n    const ItemSeparatorComponent =\n      info.section.ItemSeparatorComponent || this.props.ItemSeparatorComponent;\n    const {SectionSeparatorComponent} = this.props;\n    const isLastItemInList = index === listItemCount - 1;\n    const isLastItemInSection =\n      info.index === this.props.getItemCount(info.section.data) - 1;\n    if (SectionSeparatorComponent && isLastItemInSection) {\n      return SectionSeparatorComponent;\n    }\n    if (ItemSeparatorComponent && !isLastItemInSection && !isLastItemInList) {\n      return ItemSeparatorComponent;\n    }\n    return null;\n  }\n\n  _updateHighlightMap                                = {};\n  _updatePropsMap                                       = {};\n  _listRef                  ;\n  _captureRef = (ref                        ) => {\n    this._listRef = ref;\n  };\n}\n\n                                                \n                     \n                          \n                  \n                      \n                           \n    \n\n                                          \n                                  \n                                                       \n                                                \n                  \n                \n             \n                             \n                    \n                                 \n            \n                               \n                    \n                                 \n            \n                        \n                                                                    \n                                                               \n                       \n                    \n    \n\nfunction ItemWithSeparator(props                        )             {\n  const {\n    LeadingSeparatorComponent,\n    // this is the trailing separator and is associated with this item\n    SeparatorComponent,\n    cellKey,\n    prevCellKey,\n    setSelfHighlightCallback,\n    updateHighlightFor,\n    setSelfUpdatePropsCallback,\n    updatePropsFor,\n    item,\n    index,\n    section,\n    inverted,\n  } = props;\n\n  const [leadingSeparatorHiglighted, setLeadingSeparatorHighlighted] =\n    React.useState(false);\n\n  const [separatorHighlighted, setSeparatorHighlighted] = React.useState(false);\n\n  const [leadingSeparatorProps, setLeadingSeparatorProps] = React.useState({\n    leadingItem: props.leadingItem,\n    leadingSection: props.leadingSection,\n    section: props.section,\n    trailingItem: props.item,\n    trailingSection: props.trailingSection,\n  });\n  const [separatorProps, setSeparatorProps] = React.useState({\n    leadingItem: props.item,\n    leadingSection: props.leadingSection,\n    section: props.section,\n    trailingItem: props.trailingItem,\n    trailingSection: props.trailingSection,\n  });\n\n  React.useEffect(() => {\n    setSelfHighlightCallback(cellKey, setSeparatorHighlighted);\n    // $FlowFixMe[incompatible-call]\n    setSelfUpdatePropsCallback(cellKey, setSeparatorProps);\n\n    return () => {\n      setSelfUpdatePropsCallback(cellKey, null);\n      setSelfHighlightCallback(cellKey, null);\n    };\n  }, [\n    cellKey,\n    setSelfHighlightCallback,\n    setSeparatorProps,\n    setSelfUpdatePropsCallback,\n  ]);\n\n  const separators = {\n    highlight: () => {\n      setLeadingSeparatorHighlighted(true);\n      setSeparatorHighlighted(true);\n      if (prevCellKey != null) {\n        updateHighlightFor(prevCellKey, true);\n      }\n    },\n    unhighlight: () => {\n      setLeadingSeparatorHighlighted(false);\n      setSeparatorHighlighted(false);\n      if (prevCellKey != null) {\n        updateHighlightFor(prevCellKey, false);\n      }\n    },\n    updateProps: (\n      select                        ,\n      newProps                                       ,\n    ) => {\n      if (select === 'leading') {\n        if (LeadingSeparatorComponent != null) {\n          setLeadingSeparatorProps({...leadingSeparatorProps, ...newProps});\n        } else if (prevCellKey != null) {\n          // update the previous item's separator\n          updatePropsFor(prevCellKey, {...leadingSeparatorProps, ...newProps});\n        }\n      } else if (select === 'trailing' && SeparatorComponent != null) {\n        setSeparatorProps({...separatorProps, ...newProps});\n      }\n    },\n  };\n  const element = props.renderItem({\n    item,\n    index,\n    section,\n    separators,\n  });\n  const leadingSeparator = LeadingSeparatorComponent != null && (\n    <LeadingSeparatorComponent\n      highlighted={leadingSeparatorHiglighted}\n      {...leadingSeparatorProps}\n    />\n  );\n  const separator = SeparatorComponent != null && (\n    <SeparatorComponent\n      highlighted={separatorHighlighted}\n      {...separatorProps}\n    />\n  );\n  const RenderSeparator = leadingSeparator || separator;\n  const firstSeparator = inverted === false ? leadingSeparator : separator;\n  const secondSeparator = inverted === false ? separator : leadingSeparator;\n\n  return (\n    <>\n      {RenderSeparator ? firstSeparator : null}\n      {element}\n      {RenderSeparator ? secondSeparator : null}\n    </>\n  );\n}\n\nmodule.exports = VirtualizedSectionList              \n                       \n               \n                                     \n                                                                 \n      \n    \n                            \n ;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n *       strict\n */\n\n'use strict';\n\nfunction clamp(min        , value        , max        )         {\n  if (value < min) {\n    return min;\n  }\n  if (value > max) {\n    return max;\n  }\n  return value;\n}\n\nmodule.exports = clamp;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n *       strict\n */\n\n'use strict';\n\n/**\n * Intentional info-level logging for clear separation from ad-hoc console debug logging.\n */\nfunction infoLog(...args              )       {\n  return console.log(...args);\n}\n\nmodule.exports = infoLog;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n *      \n */\n\n'use strict';\n\n                                                           \n                                                                 \n                                                             \n                                                                           \n\nimport {                                     } from './Lists/VirtualizedListContext';\nimport {keyExtractor} from './Lists/VirtualizeUtils';\n\n             \n            \n                    \n                                \n                                   \n             \n                    \n                  \n                 \n             \n                                      \n             \n                                       \n                             \n              \n                                        \n                                                         \n\nmodule.exports = {\n  keyExtractor,\n\n  get VirtualizedList()                  {\n    return require('./Lists/VirtualizedList');\n  },\n  get VirtualizedSectionList()                         {\n    return require('./Lists/VirtualizedSectionList');\n  },\n  get VirtualizedListContextResetter()                                 {\n    const VirtualizedListContext = require('./Lists/VirtualizedListContext');\n    return VirtualizedListContext.VirtualizedListContextResetter;\n  },\n  get ViewabilityHelper()                    {\n    return require('./Lists/ViewabilityHelper');\n  },\n  get FillRateHelper()                 {\n    return require('./Lists/FillRateHelper');\n  },\n};\n"],"x_facebook_sources":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"x_hermes_function_offsets":{"0":[0,260,403,484,534,571,670,698,743,767,987,996,1146,1265,1275,1808,1818,1896,1994,2193,2353,2362,2535,2633,2777,2911,2995,3067,3151,3166,3358,3449,3673,3818,3876,4051,4070,5000,5010,5070,5141,5173,5189,5203,5217,5392,5401,5781,5889,6164,6200,6247,6257,6267,6474,6655,6766,6784,6800,6911,6986,7081,7115,7149,7407,7416,7515,7590,7753,7822,7939,7984,7998,8043,8057,8268,8346,8416,8447,8620,8761,8791,9221,9518,9541,9600,9617,9632,10030,10058,10102,10331,10604,10720,11566,11668,11677,11686,11695,11704,12561,12580,13788,14774,14788,14829,14891,14925,14956,15009,15025,15045,15416,15556,15585,15624,15754,15800,15861,15901,16030,16107,16741,16765,16788,16888,16912,16933,17056,17080,17152,17176,17270,17294,17348,17487,17554,17938,17995,18155,18603,18725,18914,19021,19096,19112,19133,19170,19216,19285,19332,19366,19402,19412,19647,20079,20154,20169,20223,20313,20334,20545,20929,20959,21025,22968,23029,23141,23163,23208,23242,23258,23367,23591,23607,23633,23655,24153,24279,24331,24369,24429,24831,25041,25061,25167,25282,25582,25602,25622,25642,25662,25672,25739,25815,25924,25967,26333,26488,26579,26922,27054,27169,27543,27552,27725,27875,27937,27999,28066,28141,28200,28231,28275,28308,28454,28959,29047,29314,29365,29495,29557,29673,29740,29749,29758,29767,29776,30032,30045,30059,30073,30087,30101,30115,30124,30133,30142,30151,30160,30169,30493,31163,31209,31242,31293,31344,31527,31718,31889,31940,32143,32270,32286,32719,32758,32797,32847,32897,32917,33178,33188,33603,33636,33645,33767,34134,34268,34288,34311,34384,34434,34599,34621,34643,34671,34693]}}